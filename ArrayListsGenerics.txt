Course Overview

Course Overview

Hello, my name is Deborah Kurata, and I'd like to welcome you to my course, C# Best Practices: Collections and Generics from Pluralsight. Aw, Generics. That challenging to explain topic that often shows up even in the most basic of beginner courses because without generics, we don't have a good way to work with collections of things and most applications require working with collections of things. In this course, we start with a classic collection type, arrays. We then jump into generics covering what they are and how we can leverage them to build more generic or generalized code. With that, we'll have the basics we need to tackle generic lists and generic dictionaries. Then we'll dive deeper into generic collections and look at the interfaces that they implement. We'll see how to leverage those interfaces as method parameters and method return types. Lastly, we'll look at Language Integrated Query, or LINQ, for our filtering, shaping, ordering, grouping, aggregating, or locating elements in a collection. By the end of this course you will know the how, when, why, and best practices for working with C# collections. I hope you'll join me on this journey through C# Best Practices: Collections, and Generics from Pluralsight.

Introduction

Introduction

When building applications, we often deal with groups of things, a user's preferences, a customer's orders, or a product's color choices. To implement these groups of things in C#, we use collections, and to get the most from collections, we need to leverage Generics. Welcome to C# Best Practices: Collections and Generics from Pluralsight. My name is Deborah Kurata, and this course covers how, when, why, and best practices for using C# collections and Generics. This course is part of a series of C# best practice courses. The series began with the C# Best Practices: Improving on the Basics course. The basics course covered how to divide an application into components, how to build good classes, properties, and methods, and included a module on string handling. In the process, it covered the key new features of C# 6. If you are already familiar with those topics, you don't need to watch the basics course to succeed with this course. Note that the sample application used in the basics course is carried over into this course. The purpose of these courses is to provide a learning path. If you were learning carpentry, there would be a step between learning how to use a saw and building a well-designed and constructed house. That step is called an apprenticeship. Think of these courses as your apprenticeship, guiding you further on the path from apprentice to skilled C# developer. So what is an apprentice? A learner, one that has ability, but has yet to achieve all knowledge, someone who wants to know more. Are you a C# apprentice? Do you want to learn more about handling collections in your applications? Do you want to leverage generics to build more generalized code? Do you want to use LINQ to query your collections? Then this course is for you. For each feature covered in this course, we'll review the how, then focus on the when, why, and best practices for using that feature. Where appropriate, we'll compare and contrast similar features, so you can confidently use the appropriate technique in the appropriate situation. This course assumes that you have some basic knowledge of C# and Visual Studio. You don't need to have much experience, but have a working knowledge of each. I'm using C# 6 released with Visual Studio 2015, but this course is equally applicable if you are using C# 5 with Visual Studio 2013. When this course covers a C# 6 feature, I'll be sure to call it out. To create our C# application, we'll use Visual Studio. I'm using Visual Studio 2015 Enterprise Edition, but you can use any edition of Visual Studio including the free community edition. You can find out more about the Visual Studio 2015 editions and download the free community edition at the link shown here. If you are using Visual Studio 2013, that will work as well. You just won't be able to use any new C# 6 features. In this first module, we'll start with an overview of collections, then provide some suggestions for getting the most from this course, including how to find the starter files if you want to code along, we'll introduce the sample application, and conclude this module with an outline for the remainder of this course. Let's begin with an overview of collections.

Collections Overview

In C#, a collection is a class that provides in-memory management of a group of items. The items can be simple types such as string literals as in this collection of product color choices or the items can be complex types, such as this collection of product objects. Each product object has an id, product name, and cost. Each item in the collection is referred to as an element of the collection. So this first collection has four elements and the second collection has three elements. A collection is most often a group of similar items, such as the color choices for a product or the list of product objects. But it is also possible to work with a group of different items, such as this collection, which contains a string literal, a product object, a user interface object, and a number. Retaining a collection of different types of items is useful when tracking changed objects, for example. There are many different kinds of collections available in C#. We can divide the majority of them into two broad categories, lists and dictionaries. A list allows us to manage a group of things. We then retrieve an element by index, which is the position of the element in the list. In C# the index numbers are zero-based meaning that the first element in the list has an index of 0, the second element is 1, and so on. In this example list of product colors, if we retrieve using an index of 1, we get espresso, which is the beautiful brown color of an Italian coffee. If we retrieve using an index of 3, we get navy blue. A dictionary allows us to manage a group of things each with an associated unique key. We then retrieve an element by that key. This example dictionary contains US states with their abbreviations. If we retrieve using a key of CA, we get California. If we retrieve using a key of NY, we get New York. In most cases, when using collections in our applications, we want the collection to contain all of the same type of thing, for example, a list of product objects or a dictionary of strings containing state names. To help ensure that the collection contains only the desired type of thing, it is important to specify a collection of what. That lets the compiler know what type of elements we expect in the collection. The tooling can then tell us if we attempt to put something odd into our collection. We'll see this in action when we start working with specific types of collections in the next module. Now let's look at a few tips for getting the most from this course.

Get the Most from This Course

Thoughts, comments, or questions as you watch this course? Feel free to use the Discussion tab to leave your feedback. Though you may not see all of the options here, you can find the link to the discussion on the Pluralsight page for this course. It would be great to hear your thoughts on the best practices presented here and any additional tips you have to share with other developers. I have set up a public GitHub repository specifically for this course. It is called CSharpBP-Collections. You can find it at this URL. It contains the starter files for the sample application. You can use these files as a starting point if you want to code along with the demos. If you are new to GitHub, simply click this button to download the code as a zip file. Note that these are only the starter files and not the completed source code for this course. Let's dive into a demo of these starter files as an introduction to the sample application we will use throughout this course.

Sample Application

I have downloaded the starter files from my public GitHub repository as discussed on the prior slide, and then I opened the provided solution file in Visual Studio. I am using Visual Studio 2015 Enterprise Edition, but any edition of Visual Studio 2015 would work, including the free community edition. Visual Studio 2013 would also work for the majority of the demos in this course. This application is for a fictitious company called Acme, Inc. The purpose of this application is to manage the approved vendors Acme uses for purchasing products that Acme then resells. The solution is organized into four projects. Here is the Windows forms project for some of the application's user interface. Here is the Wpf project for more of the user interface. Here is the common code library project and here is the business logic layer project. In this course, we will focus primarily on this business logic layer component. Inside the business logic layer is a product class that manages each product Acme carries in inventory, a vendor class that manages each approved vendor, and a vendor repository class that encapsulates the interaction with the data access technology in order to retrieve vendors. Each of these classes has just the minimum functionality required to demonstrate the concepts presented in this course. This application is not meant to be full-featured or production-ready. In the Tests folder are the unit tests for these classes. We can open the folder for the business logic layer and open the ProductTests file to view the existing product tests. Each test is coded in three steps, Arrange to setup the test, Act to call the method under test, and Assert to assert the result. To run all of the tests, open the Test Explorer using Test, Windows, Test Explorer. We'll pin the window, and then select Run All to run all of the tests. We can see by the green checkmarks that the current tests all pass. We'll be using unit tests throughout this course to try out the code we write. Now let's finish up this introductory module with a look at the outline for the remainder of this course.

Course Outline

We'll begin with the most fundamental type of collection in C#, arrays. We'll look at how to define and use an array and best practices for working with arrays. Next, we'll dive into generics. We'll look at what they are and how we can leverage them to build more generic or generalized code. Then we'll see how generics improve how we work with collections in C#. We'll examine how to define and use a generic list and cover best practices. Sometimes we need more than just a list. We need keys associated with each element in the list. That is the purpose of dictionaries. We'll cover how and when to use generic dictionaries including best practices. Then we'll dive deeper into generic collections and look at the interfaces that they implement. We'll start with an overview of interfaces and why they are useful. Then we'll look at best practices for using generic collection interfaces. LINQ, or Language Integrated Query, is great for filtering, shaping, ordering, grouping, aggregating, or locating elements in a collection. So we'll cover the basics of using LINQ including LINQ queries, delegates, and lambda expressions. The final words in this course includes some takeaways and a few pointers to additional information. Let's get started.

Arrays

Introduction

Arrays are a fundamental feature of many programming languages, including C#. We can use arrays to manage collections of things such as a set of color choices. Welcome back to C# Best Practices: Collections and Generics from Pluralsight. My name is Deborah Kurata, and this module covers best practices for defining and using arrays. An array is a fixed-size list of elements that can be accessed using a positional index number. For example, here is an array of color choices and here is an array of product objects. In C#, the index is zero-based meaning that the first element in an array has an index number of 0. Unlike other types of lists, arrays are fixed-size. That means that we must define the desired size of the array when we initialize it, and once initialized, we can't adjust that size. In this module, we'll evaluate different ways to initialize an array. We'll start with basic declaration and population, then use collection initializers to reduce the number of lines of code. We'll look at how to retrieve an element from an array and iterate through all of the elements of an array. We'll try out some of the static and instance methods available when working with arrays. These methods provide features such copying or sorting an array. We'll conclude with a set of frequently asked questions. These are the types of questions that you may see in a C# programming interview. Let's get started.

Declaring and Populating an Array

Before we can declare an array, we need to answer the question, collection of what? We need to consider the type of element that the array will contain. For our example, we want to work with a set of color option names, so we want an array of strings. To declare an array, we specify the array element type followed by square brackets and the variable to reference the array. So this is our array declaration. In this example, we specify a string type for the array elements. This particular array can then only hold string elements. Arrays can hold a value or reference type, so we could use int here to declare an array of integers or DateTime to declare an array of dates or we could use product here to declare an array of product object instances. Next, we need to initialize the array. In C#, an array is a reference type, so it is declared similar to other reference types using the new keyword. To initialize the array, we assign the array variable to a new array instance. We again specify the array element type, but here we must define the size of the array within the square brackets. A size of 4 means that there are 4 elements in this array indexed as 0 through 3. When an array is instantiated, it is initialized to contain the defined number of elements and each element is set to the default appropriate for the specified array element type. In our example, the array element type is string, so each array element is set to null, which is the default value for a string. Now we have declared an array and initialized it to four elements. We can combine the declaration and initialization on one line like this. Then because we have the array type defined on the right, we can use implicit typing with the var keyword, as shown here. C# will then implicitly determine the type of the color options variable based on the type declared on the right. These three techniques are functionally equivalent. Though, many developers prefer this last syntax because they find it less repetitive and easier to read. Note that this array is single dimensioned meaning that it is a simple list of things. We can also define multidimensional arrays, and since an array can contain elements of any value or reference type, we could even create an array of arrays. For our demos however, we'll stick to the most commonly used single dimension array. Once the array is declared and initialized, we populate the array by putting elements into the positions of the array. We access the array elements using square brackets and the element index. So to put red in the first element, we use colorOptions, bracket, 0, bracket. This replaces the null value in that position with Red. We can repeat this for each color option. Let's try this out. Here we are in Visual Studio. Let's add an array of colorOptions to the product class. For simplicity, we'll define the array in the constructor. We first need to declare a variable. We'll use simplicit typing with a var keyword for the variable declaration, and we'll call it colorOptions. Then we set the variable to a new instance of a string array. We want 4 elements in the array, so we'll size the array to 4. Next, we want to populate the data for those four array elements. Recall that the first element is at index 0. In the first element, we'll add the string Red. I'll paste the rest. Lastly, we'll add a Console.WriteLine to write out our array. Let's see what happens if we try to put something else into this array. We can try to put an integer, say 5 at index 3. Notice that we immediately see a syntax error, cannot implicitly convert type int to string. By defining the array element type, Visual Studio can help ensure that the array only contains the elements of the appropriate type. Let's change this back. Now let's try running this. We'll put in a breakpoint right after the declaration. We'll use one of our ProductName unit tests to run this with a debugger. Notice that when the array is initialized, it is immediately created with four elements. The value of each element is the default appropriate for the element type. In our case, our array elements are strings, so the default value of each element is null. As we step through this code, the element is updated with the string we assigned to that element. We'll just finish the test. So we first declared a variable to hold a new instance of a string array with 4 elements. We saw that the array is immediately created with those four elements. We then saw how to reference an element of the array using square brackets and the index and replace the null element with a meaningful value. Before moving on, let's look at some generally accepted best practices for declaring and populating arrays. Do consider using arrays when the required size of a list can be determined at design time. Arrays use memory efficiently and perform well. However, you may discover that other types of lists are more convenient and find that you only use arrays when you need multiple dimensions or to squeeze out a bit more performance when working with a large fixed number of elements. Avoid using arrays when the size of the list is not known, such as when the data comes from a database. Instead, use one of the other list types we'll see later in this course. Do use a plural variable name for the array. A plural name implies that the variable holds multiple elements making the intent more clear. We've now seen how to declare an array and set desired values into the elements as two steps. If you are thinking there has to be an easier way, you are right.

Using Collection Initializers

To simplify the syntax for declaring and populating an array, we use a technique called collection initializers, so we can change these five lines of code to one line of code like this. With collection initializers, we can initialize the collection as we define it. Simply add curly braces after the instantiation. Within the curly braces, define the elements for the array separated with commas. So we've reduced the code required to declare and populate an array down to one line, but that's still not enough. Since we have the type now defined on the left-hand side and because the collection initializer syntax defines how many elements we need, we can remove the new clause that reduces the code to this. That's more like it. And though this example uses string literals, these could be expressions that result in a string like this. Let's try this out. Here we are back in Visual Studio with the ProductClass open. Let's simplify our code using collection initializers. I'll copy and paste our original declaration and then comment out this code, so we still have it here for comparison. First, we need to replace var with the array type on the left. Then we can remove the explicit instantiation and simply define curly braces and the list of desired elements. That looks better. Let's set a breakpoint. We can, again, use the unit test to confirm that our array contains the elements we expect and it does. So we are using collection initializer syntax here to simplify the creation of our array. Which technique do you think looks easier to read? Before moving on, let's look at some generally accepted best practices for initializing arrays. Do use collection initializers. They provide a much clearer syntax for declaring and populating an array. Avoid manually populating an array. When manually populating an array, it is easy to misnumber the index and cause hard-to-find bugs or generate a runtime exception. Now that we know how to put values into an array, let's look at how to get those values out.

Retrieving an Element from an Array

We have seen how to use square brackets and the array index to put values into the array. We use the same technique to retrieve values from an array. Let's see how this works. Here we are back in Visual Studio with the ProductClass open. Notice that we added a line here to write the colorOptions to the console. Let's see what that displays. At the bottom of the Test Explorer, click on Output. We can see that writing color options to the console simply displays the array element type, which is string in this case. Let's instead, locate and display the second element, which is espresso. To retrieve an element value from the array, we use the array variable and identify the desired element index within square brackets. Since the array is zero-based, the second element has an index of 1, so this syntax will retrieve the element with an index of 1 and display it to the console. Now if we re-run our unit test, and click Output, we see the expected value. But what if we retrieve an element using an index number that is out of range, say 5. The compiler doesn't catch it, but if we re-run our unit test, we get a runtime error. Index was outside the bounds of the array, so anytime we need to retrieve an element value from an array, use the array variable and specify the index of the element in the square brackets. Just be sure that the index number is valid. Before moving on, let's look at some best practices when retrieving elements from an array. Do take care when referencing array elements by index. An index that is out of bounds will generate a runtime exception. Avoid retrieving elements by index when you need all of the elements. Instead, iterate through the elements. So next, let's look at how to iterate through the elements of an array.

Iterating Through an Array

There are oftentimes you need to iterate through all or some of the elements in an array. For example, process each element and a list of products to purchase or loop through each string element to display it to the user. C# provides two ways to iterate through an array. The foreach statement repeats a group of statements for each element in an array. The elements are processed in index order. The for statement repeats a group of statements while a specific condition is true. It iterates using an integer value. We can use that integer value as an index to access our array elements. Let's try out each of these. We are back in Visual Studio with the ProductClass open. So far in our example, we are displaying one of the colorOptions to the console. Using this technique, we can display each of the four color options, but that result in repetitive code that was prone to error. We can instead use a foreach statement to easily iterate through each element of the array. We'll add the foreach here right after defining the array. Type foreach, tab, tab to use the Visual Studio snippet to create the foreach statement. This snippet allows us to specify the element type. We'll stick with var here to use implicit typing. Next, we define the name of the iteration variable. We'll use color. The iteration variable is a read-only local variable that represents the current element in the array. Lastly, we specify the array variable, which is colorOptions. In the body of the foreach statement, we defined the lines of code that are repeated for each element in the array. In our example, we'll display the color to the console using the C# 6 string interpolation feature. If you are using Visual Studio 2013, you can use String.Format here instead. If you want more information on the C# 6 string interpolation, see the C# Best Practices: Improving on the Basics course. This statement we'll write The color is and the color to the console. Let's try this out using our unit test. Run the unit test, and click Output. Here we see each of our colors. We can easily use foreach anytime we want to iterate through all of the elements in an array, but foreach has some limitations. Foreach always goes through all of the elements in the array. We can't just iterate through some of them. Sure, we could have some logic here to skip elements under some circumstances, but it will still iterate through every element. Also, when using foreach, the element itself cannot be changed. For example, say we want to change each element to lowercase. If we try to change the iteration variable, Visual Studio marks it as an error, cannot assign to color because it is a foreach iteration variable, so we can't modify the value here. Let's see how to get around these issues by using the for statement instead. Let's try out the for statement above the foreach. We can again use a snippet. Type 4, tab, tab. First, we specify the initializer variable. In most cases, we can just leave it as i. To iterate starting at the first element, we leave the default starting value at 0. Next, we specify the conditional expression. To iterate over all of the elements, we want to iterate while the index is less than the length of the array. What do we put for the length? Luckily for us, an array has a length property, so we can use that here. Lastly, the for statement has an iterator defining how the initializer variable is modified during each iteration. If we want to iterate through every element, we can simply increase the index by one at the end of each iteration. Inside the for, let's change each element to lowercase. We can access an element using the initializer variable as an index and we can use the ToLower string method to change the text to lowercase. Let's try this out using our unit test. Click on Output and it lists each of our colors in lowercase. Unlike the foreach, with the for, we can change the value of the element within the iteration and we could easily change this code to only process some of the elements. We could change the iteration to begin at 1 or end at 2, for example, or process every other element by incrementing the iterator by 2. Using 4 provides much more flexibility than the foreach when working with arrays. Before moving on, let's compare the two iteration techniques. Foreach syntax is quick and easy. For syntax is a little more complex, but is also more flexible. Foreach is useful when iterating all of the elements in an array. For is useful when iterating overall or a subset of elements. The foreach iteration variable that provides each array element is read-only, so we can't modify array elements as they are iterated. Using the for syntax, we can modify the array elements as needed. Bottom line, use foreach to quickly iterate all of the elements of an array. Use for to iterate a subset of the elements of the array or to modify array elements as they are iterated. Next, let's look at some array methods.

Using Array Methods

In C#, our arrays derive from the .NET System.Array class, so all of the System.Array methods for working with arrays and array elements are available to our arrays. System.Array provides static methods, such as IndexOf, and instance methods, such as SetValue. Recall from the C# Best Practices: Improving on the Basics course that static methods are called using the class name, so we can access the static methods using Array dot. Instance methods are called using the array instance such as colorOptions in our examples. So we can access the instance methods using colorOptions dot. Let's try out some array methods. Here is the ProductClass once again in Visual Studio. Let's start by looking at the static methods. To access a static method type Array dot. IntelliSense then displays the list of available static array members. Those with less than and greater than signs after them are generic methods. We'll cover generics later in this course, so we'll skip those for now. There is a copy to copy an array to another array. There is sort to sort the array elements. Let's try out IndexOf. IndexOf allows us to find the index of a specific element. Let's define brownIndex as the index of the element in the array containing espresso. Since we used the class name to call the static method, we need to pass in the array we wish to work with, in this case, colorOptions. The second argument is the value we wish to get the IndexOf, in this case, espresso. We'll again use a unit test to try this out. We'll set a breakpoint and debug the test. When we break here, we can see that brownIndex is set to 1, which is correct. Espresso is the second element, so it has an index of 1. Now let's try out an instance method. To access an instance method, type the array instance variable and a dot. There are lots of instance methods with less than and greater than signs after them. These, again, are generic methods, so we'll skip those for now. Let's try out the set value method. This method changes the value of a specific element using a method instead of using the array square bracket syntax. Let's set blue into the element at index 3. Let's run the unit test again, and click on Output, and we can see that the last element now is blue. To use any of the static methods, use Array dot, and to use any of the instance methods, use the array instance variable dot. Now let's conclude this module with some frequently asked questions.

Frequently Asked Questions

As a review, let's look at some frequently asked questions. These are the types of questions often used in job interviews. When is it appropriate to use an array? When working with a list of elements whose length is defined at design time. Arrays are a fixed length and therefore appropriate when the list length is known. However, you may discover that other types of lists are more convenient and find that you only use arrays when you need multiple dimensions or to squeeze out a bit more performance when working with a large fixed number of elements. What is the difference between foreach and for when iterating through an array? Foreach provides simple syntax for iterating through all elements in an array. For provides more complex, but flexible syntax for iterating all or any subset of elements in an array. Plus the iterated elements are updateable. In this module, we detailed out to define and work with arrays. We began with a syntax for declaring and manually populating an array. We found that syntax to be long and prone to error. So we tried out collection initializers to populate an array as part of a declaration. This resulted in much more concise code. Once we had elements in an array, we saw how to retrieve the values of those elements from the array. We then looked at two techniques for iterating through the elements of an array, foreach and for. Lastly, we tried out some array methods and saw that there are both static methods and instance methods available to help us work with arrays. Before we can look at any of the other popular collection types, we need to cover generics. Let's do that next.

Building Generic Code with Generics

Introduction

Generics are a powerful feature that allow us to write more reusable code, and many of the built-in C# collection classes use generics to provide type-safe collections. Welcome back to C# Best Practices: Collections and Generics from Pluralsight. My name is Deborah Kurata, and this module covers the what, why, when, and best practices for building generic classes, generic properties, and generic methods. Generics are a technique for writing code without specifying data types and yet still providing type-safety, which means everything has a data type and the compiler validates those types while compiling. Generics are a way to make our code, well, more generic. In this module, we'll discover what all of this means. We'll start with a demo to build the case for generics. Then we'll build a generic class and demonstrate how we can write more reusable code with generics. Next, we'll see how to use a generic class including how to strongly-type an instance of the generic class. We'll cover generic methods and see how to leverage generics for the method return type or any of the method parameters and we'll briefly look at the more advanced topic of generic constraints. We'll conclude with a set of frequently asked questions. These are the types of questions that you may see in a C# programming interview. Let's get started.

Making the Case for Generics

Before looking at the how of generics, let's look at the why. Why have generics in C#? The use case for generics is best illustrated with a demo. Let's jump right in. Here we are in Visual Studio. Here is the Acme.Common code library component. It is part of the starter code for this course that you can download from GitHub. One of the classes in that component is OperationResult. The purpose of the OperationResult class is to provide an object we can use to return multiple values from a method. As it is written, it provides a Boolean success flag and an associated message string. If we look at the Vendor class, we see that the PlaceOrder method returns an instance of the operationResult class. This allows us to return both a success flag and the text of the order. That way, we can display the orderText to the user as part of the order confirmation. Now let's look at the Product class. Here is the CalculateSuggestedPrice method. In the C# Best Practices: Improving on the Basics course, we use this method to demonstrate the new C# 6 expression-bodied method syntax, which allows us to define the method with the single code line. The problem with using the expression-bodied method syntax is that the method then has no guard clauses to validate the incoming parameters. Let's change this back to a normal method and add some guard clauses. I'll paste the code and then we can talk through it. In this code, we set up the guard clauses. If the markup percentage is less than or equal to 0, the message states that the percentage is invalid. If the markup percentage is less than 10, the message is a warning that the percentage is lower than the minimum markup required by management. How are we going to return these messages along with the calculated value? Well we could use the operationResult class, but for the CalculateSuggestedPrice method, we need to return a decimal and a message, instead of a Boolean and a message. We could change the bool type here to object, then we could return a value of any type, but the code would not be strongly-typed and would be more prone to error. Let's instead create a second class, OperationResultDecimal. It is very similar to the original OperationResult class, but instead of defining a success flag in a message, it defines a decimal Result and a message. Back in the Product class, we can now modify the CalculateSuggestedPrice method to return an instance of this OperationResultDecimal class. This method now returns both the calculated value and any desired message. But now we have two different OperationResult classes and if we want to use OperationResult for another method that needs to return an integer in a string, we'd need to create a third class, OperationResultInteger, and on, and on. This certainly breaks the DRY principle, Don't Repeat Yourself. We have the same basic code here multiple times, once for each data type. Hmm, wouldn't it be nice if the data type here was sort of a variable and we could use the OperationResult class to return a result of any desired type? See where we're going here?

Building a Generic Class

In the last demo, we saw how we could create multiple copies of the OperationResult class, one for each data type, but that path leads to a lot of duplicated code. Let's see how we can use generics to build a single, reusable, OperationResult class that works with any data type. We are back in Visual Studio with the OperationResult class open. First, let's rename the success flag to Result, so it is more appropriate for any data type. We'll change it here in the declaration and also in the constructor. Next, let's change the type of the result to be any type. We do that by simply changing the type of the property from Boolean to a variable. By convention, the capital letter T is often used to represent that type variable. This variable is called the generic type. By using a variable type here, we can reuse this property to return a Boolean, integer, decimal, or whatever. We get a syntax error here because we are using this variable, but have not defined that variable anywhere. Just like any other variable, we need to define the variable T somewhere. When using a generic type on a property as we are here, we define the T variable on the class signature. The syntax for defining a generic type requires putting the T in angle brackets after the class name. The T here is called a type parameter and the syntax is read public class OperationResult of T. Our OperationResult class is now a generic class because it has a generic type parameter. Let's fix our syntax error here. The Result property is of type T, our variable type, so the constructor parameter must also be of type T. We just changed the bool here to T as well. We now have a completed generic class. This class has two properties, a result that can be any type, and a message, which is a string. We defined a generic class by adding T and angle brackets. This T is a type parameter and it represents our desired data type. We can then use T anywhere we would normally specify a type. Here we used it as the type of our Result property and as the type on one of the constructor's parameters. Let's pop back to the slides and review what we've done. Generics allow us to define a variable data type. In this example, we want the Result property to be any type. We represent that any type with T. This allows us to reuse this class whether we want the result to be a Boolean, a decimal, an integer, or whatever. We then need a way to pass in the definition of the actual type to specify what T represents. For properties, we define the type in the class signature with a type parameter, so we change the OperationResult class from a normal class to a generic class, OperationResult of T. We can add any number of generic properties to our generic class. For example, say we also want the message property to be any type. Each type variable is included in the class signature as type parameters separated by commas. Whatever type is passed into the first parameter is used wherever T is specified and the type passed into the second parameter is used wherever V is specified. How do we use a generic class? That's coming up next. Before moving on, let's look at some best practices when building a generic class. Do use generics to build reusable, type-neutral classes. Avoid using generics when it is not needed. If a class will never be used with other data types, don't make a generic. Using generics unnecessarily can cause confusion and hard-to-find bugs. Do use T as the type parameter for classes with one type parameter. Anyone familiar with generics will expect and understand that the T represents the type. Avoid using single-letter names when defining multiple type parameters. Use a descriptive name instead. It is easier to use a class with multiple type parameters if the intent of each parameter is clear. Do prefix any descriptive type parameter with T. This makes it clear that the symbols represent type parameters. In this example, it is clear that there are two type parameters, one for the result and one for the message even without looking at any of the class code. Now that we have built a generic class, let's see how to use it.

Using a Generic Class

C# is strongly-typed, so when we use a generic class such as this OperationResult of T class, we need to define what type that the T type parameter represents. We specify the actual type when we create an instance of the class. We, again, use the angle brackets and define the desired type. In this example, we create an instance of the class and define the generic type parameter to be Boolean, so this instance of the OperationResult of T class is created using Boolean for T. The Result property is then of type Boolean and the result variable passed into the constructor is of type Boolean. In this second example, we create an instance of the same OperationResult of T class, but we define the generic type parameter as decimal. So this instance of the OperationResult of T class is created using the decimal data type for T, the Result properties of type decimal, and the result variable passed into the constructor is of type decimal, so different instances of this class can specify different data types. Let's see this in action. We are back once again in Visual Studio with the OperationResult of T class open. We now want to use this generic class. Let's start with the PlaceOrder method in the Vendor class. Here we are creating the instance of the OperationResult class. We need to define the type that we want it to use in this particular instance. For the PlaceOrder method, we want the T type parameter to be a Boolean, so we add bool within angle brackets here. Notice that we have a syntax error on the class signature. We are now returning an OperationResult of bool, so we need to change the return type on the method signature as well. That's better. To try this out, we can run the unit test that come with the starter files for this course, but first, we need to update them. Open the unit test file. Each of the PlaceOrder tests expect a return value of OperationResult. Now the return value is OperationResult of bool, so we need to add of bool to each OperationResult class constructor. Now that all of our syntax errors are fixed, we are ready to run the tests. Right-click in the test file somewhere not within a specific test and select Run Tests. Looking at the Test Explorer window, we can see that they all pass. To really see how we can reuse this OperationResult of T class, let's go to the Product class and reuse the OperationResult of T and the CalculateSuggestedPrice method. Currently, we are returning an instance of the OperationResultDecimal class. Let's change it to OperationResult of T, and in this particular case, we want the type to be decimal, so we set the type argument to decimal, and we'll update the method return type accordingly. Now let's jump back to the OperationResultDecimal class and delete it. We no longer need that specialized class. To try out our updated CalculateSuggestedPrice method, we can use the product unit test that come with the starter files for this course, but first, we need to update the CalculateSuggestedPrice test for the changes we made to the associated method. The CalculateSuggestedPrice method originally returned a simple decimal value, so we set the expected to a decimal. Now its return value is OperationResult of decimal, so we can change expected appropriately. We expect the calculated value to be 55 and no message. We also need to change the Assert. We want to assert both the result and the associated message. Now we are ready to run the test. Right-click in the test and select Run Tests and it passes. So we've seen how to create and use a generic class and how to declare a generic property. Now let's look at how to define a generic method.

Defining Generic Methods

When building methods, there are even more ways to use generics. Here is the signature for a basic method that uses a SQL statement to retrieve a single value from a database. This method takes in a SQL statement and a default integer value. The method returns the retrieved integer value. We want to reuse this method to retrieve other types of values from a database such as a decimal, or a string, or a date. We can change this method to leverage generics like this. We can then use this method to retrieve any type of value from a database. Where do we define what T represents? We could define the type parameter on the class signature similar to how we define generic properties, but there is another way. We can define the type parameter directly on the method signature like this. By specifying the type parameter on the method signature, different methods within a class can work with different type parameters. This provides much more flexibility. Just remember, when specifying the type parameter, define the type parameter variable within angle brackets. When using the type specified in the parameter, use the variable alone. Let's try this out with a demo. We are back once again in Visual Studio. This time we have the VendorRepository class open. The repository class provides the methods that interact with the database. Let's build a RetrieveValue Method with a signature like we saw on the prior slide. This method takes in a SQL statement and an integer default value. The method returns the retrieved integer value or the default value if no value is returned from the SQL statement. Note that we are using pseudo code here, instead of executing the SQL statement, so we can remain focused on generics. Currently, this method can only return an integer value. To make this method generic, we need to do two things. Remember what they are? First, we replace the specific type with a variable often represented by T. We want this method to retrieve any value, so we'll change the return type here to the variable T and the type of the default value here. We also need to change the type of the value returned from this method here. Now we need to define the type parameter used to pass in this specific type. We could modify the class signature to include the T type parameter, but since there are no other properties or methods in this class that require that type parameter, we'll add the type parameter to the methods signature instead. Now this method can retrieve and return any type of value from the database and retrieve value is now a generic method. Let's give this a try by building a unit test. Right-click in the method and select Create Unit Tests. Note that if you are using Visual Studio 2013, this option may not be available and you may need to manually create this test. Click OK and the test method signature is created. I'll paste the code for the body of the test and we can talk through it. To arrange this test, we create an instance of the vendor repository. Notice that we don't have to specify any type arguments here. We also defined the expected result. To act, we call the method under test, which is our RetrieveValue method. Here we define the type argument as part of the call. For this test, we retrieve an integer value. Notice that we are not passing in a valid SQL statement here, but we are passing in a real default value. To assert, we'll check the expected against the actual value from the method. To show how to reuse our generic method, let's repeat this test and try it again with a string value. I'll paste the code and we can talk through it. To arrange this test, we again create an instance of the VendorRepository. We also defined the expected result, in this case, a string. To Act, we call the RetrieveValue method. Here we define the type argument as part of the call. For this test, we'll create a string value. To Assert, we check the expected against the actual value from the method. Now let's run our tests. Right-click anywhere in the file that is not in a specific test and select Run Tests. And they both pass. When creating a generic method, like in our VendorRepository class, the return type can be a generic type. One or more of the parameters can be a generic type or one or more of the variables in the method can be a generic type. The generic type parameter can be defined on the class signature or directly on the method signature as we have done here. Use the class signature if multiple members of the class need the same type parameter. Use the method signature if only this method needs the type parameter. Before moving on, let's look at some best practices when building a generic method. Our best practices here for generic methods are similar to those used when defining generic classes. Do use generics to build reusable, type-neutral methods. Avoid using generics when it is not needed. If the method will never be used with other data types, don't make a generic. Using generics unnecessarily can cause confusion and hard-to-find bugs. Do use T as the type parameter for methods with one type parameter. Anyone familiar with generics will expect and understand what the T represents. Avoid using a single letter name when defining multiple type parameters. Use a descriptive name instead. It is easier to use a method with multiple type parameters if the intent of each type parameter is clear. Do prefix any descriptive type parameters with T. This makes it clear that the symbols represent type parameters. In this example, it is clear that there are two type parameters, one for the return value and one for the SQL parameter. Do define the type parameters on the methods signature, not on the class signature, unless multiple members use the same type parameter. As it is now, our generic code can literally take any type. What if we want to limit the acceptable types to certain kinds of types? Let's look at that next.

Leveraging Generic Constraints

Generic constraints provide constraints on generic type parameters. They allow us to limit the types that can be used with our generic types. Let's start with a look at the use case for generic constraints. We are back in Visual Studio once again with a VendorRepositoryTest file open. Let's write another unit test for RetrieveValue. I'll paste in the code and we can talk through it. Let's say we want to try to call the generic RetrieveValue method and return a vendor object. We can arrange by creating an instance of both the VendorRepository and the Vendor class. We act by calling the method setting vendor as the type argument, then we assert that the vendor is the expected vendor. Let's run this test and it passes. But what does this code really mean? A SQL statement can't really return an instance of a vendor object. This only works because we don't have real code in the RetrieveValue method. So how do we prevent someone from trying to call our method with an object? Wouldn't it be nice if we could limit the types passed in as our type parameters? That's the purpose of generic constraints. We can constrain our generic type parameters to limit the types that can be used with our classes or methods. Let's now look at the constraint options. Generic constraints are defined with the where keyword, the generic type parameter name, T in this example, a colon, and the constraint keyword. The valid constraints include struct. Use struct when the type argument must be a value type. Only value types, except for nullable types, can then be used as the generic type argument. Use the class keyword when the type argument must be a reference type. Only reference types, including any class, interface, or array type can be used as the generic type argument. Use the new with open and closing parens, if the type argument must have a public parameter list constructor. This is often called the default constructor. This constraint allows us to create a new instance of T in the generic code, because the constraint requires that T must have a public parameter list constructor. We'll see an example of this in an upcoming slide. We can constrain T to a specific class. The generic type argument must then be, or derive from, the specific class, vendor in this case. And the class must not be sealed, meaning it is available to be inherited from. We can constrain T to a specific interface. The generic type argument must then be or implement the specified interface. That's it! These are the only generic constraints available. Where does this where clause go? Here is a simple example of a generic constraint on a class signature. In this example we apply a generic constraint by adding a where clause at the end of the signature. The value after the where keyword is the generic type parameter name, then a colon, and the constraint. The struct constraint in this example limits the generic type argument to value types, such as end or bool. If a generic type parameter has multiple constraints, separate them with commas. In this example we define a populate method that can populate any object from a SQL statement. In this case, we use the class constraint to restrict to only reference types. And we want to create a new instance of the object within the method. So we add the new constraint to ensure that the type has a public parameter list constructor. If there are multiple generic parameters with constraints, add multiple where clauses as shown here. There are limits to what these generic constraints can do; and there are many scenarios that these constraints just can't handle. For example, here is our RetrieveValue method. It makes sense for this method to return a string, integer, date, and so on. So we would like our method to accept strings or value types as the type parameter. We can add the struct constraint to constrain it to value types, but then we would not be able to use this RetrieveValue method with strings because strings are reference types. To allow both value types and strings we would have to add an overload that accepts strings. This method would allow for integers, decimal, dates, and any non-nullable value types; and this method overload would allow for strings. So, generic contraints are helpful but somewhat limited. Let's conclude this module with some frequently asked questions.

Frequently Asked Questions

As a review, let's look at some frequently asked questions. These are the types of questions often used in job interviews. What are generics? A technique for defining a data type using a variable. What are the benefits of generics? With generics we can write generalized reusable code that is type-safe, yet works with any data type. What is a generic type parameter? A placeholder for the specific type when using a generic type. In this example, the T is the generic type parameter. Where is a generic type parameter defined? As part of a class signature or as part of a method signature. In this generic class example, how do you define the actual type for T? The type is defined when calling the class constructor. In this first case, the actual type is decimal. In the second case, the actual type is a Boolean. What is the purpose of a generic constraint? To limit the types accepted for a generic type parameter. This module was all about generics. We began with a look at why generics are an important C# feature and how they can reduce repeated code. We saw how we could build a generic class that would work with any data type and yet still be type-safe. We then used our generic class in two scenarios. First, constructing an instance of our class using a Boolean type and a second using a decimal type. We covered how to build a generic method. Methods can use generic types as a return type, as the type of any method parameter, or as the type of any variable within the method. Lastly, we took a brief look at generic constraints and how we can use them to limit the types accepted by the generic type parameter. Did it seem odd that there is a module on generics here in a course on collections? There is a method to my madness. Generic collections are up next.

Generic Lists

Introduction

Now that we have covered generics, we are ready to explore one of the most commonly used collections in C#, the generic list. Welcome back to C# Best Practices: Collections and Generics from Pluralsight. My name is Deborah Kurata, and this module covers the what, why, when, and best practices for defining and using a generic list. A generic list is a strongly-typed list of elements that is accessed using a positional index number. Hmm, that sounds quite a bit like the definition of an array from earlier in this course. Let's compare the two. An array is strongly-typed, meaning that we define the type of elements in the array and only elements of that type are allowed in the array. A generic list is also strongly-typed, but it uses generic type syntax as we'll see shortly. An array is a fixed length. Once the array is initialized to a size, it cannot be changed. A generic list is expandable to any size. An array has no ability to add or remove elements. We can only replace an element at a specific position in the array. With a generic list, we can add, insert, or remove elements as needed. An array can multidimensional. A generic list is always one-dimensional. Bottom line, in most scenarios, a generic list is the best choice for managing an in-memory collection of elements. As we'll see in this module, its flexibility makes it easy to work with. Only use an array if you need multiple dimensions or to squeeze out a bit more performance when working with a large fixed number of elements. As indicated by the name, the generic list leverages generics. So the generic list is written as List of T. Recall from the prior module that the T represents any type. When used with the generic list, T defines the type of elements contained in the list. We then specify the actual type when we create an instance of a generic list. So we can define a list of integers, decimal values, strings, objects, such as product instances, or any type we need. In this module, we'll start with the basics of declaring and populating a simple generic list. Then we'll use collection initializers for more concise code. Because we often need to manage collections of objects, we'll examine how to declare and initialize a list of object instances. Then we'll look at how to retrieve an element from a generic list and iterate through all of the elements of a generic list. In addition to arrays and List of T, there are many other types of C# lists. We'll take a brief look at a few of them. We'll conclude with a set of frequently asked questions. These are the types of questions that you may see in a C# programming interview. Let's get started.

Declaring and Populating a Generic List

Before we can declare a generic list, we need to answer the question, list of what? We need to consider the type of element that the list will contain. For our example, we again want to store a set of color option names, so we want a list of strings. To declare a variable as a generic list, we specify the data type as list and use the generic type argument to specify the type of elements the list will contain, so this is our list declaration. In this example, we declare a list of strings. This particular list can then only hold string elements. Next, we need to initialize the generic list. A generic list is a reference type, so it is declared similar to other reference types using the new keyword. We assign the list variable to a new instance of the generic list class. Here we must again specify the element type. This then calls the constructor of the .NET generic list class and instantiates the list. So now we have declared and initialized a list of strings and the list currently contains no elements. We can combine the declaration and initialization on one line like this. Then because we have the list type defined on the right, we can use implicit typing with the var keyword as shown here. C# will then implicitly determine the type of the colorOptions variable based on the type defined on the right. These three techniques are functionally equivalent, though, most developers prefer this last syntax because they find it less repetitive and easier to read. Once the generic list is declared and initialized, we can add elements to populate the list. The list class provides an Add method for adding elements to a list. The argument to the Add method is the element to add. The Add method always adds the element to the end of the list. So this code adds Red to the list. We can repeat this for each color option and the text of each color is added to the bottom of the list. If we want to add an element into a specific location in the list, we can use the Insert method. The second argument of the Insert method is the element to insert. The first argument is the index defining where we want to insert the element. Since the index is zero-based, specifying an index of 2 inserts the element into the third position moving all of the other elements down like this. Take care when specifying the index because specifying a number out of range will result in a runtime exception. We can also remove elements from the list using the Remove method. The argument here defines the element to remove. In this example, it removes the color white from the list like this. The Remove method removes the first matching element that it finds. So if there were multiple elements in this list containing white, only the first would be removed. Let's try out these features in a demo. We are back in Visual Studio with the Product class open. Here in the constructor is all of the code we added earlier to work with an array. Let's delete all of this and instead define a list of colorOptions using a generic list. Before we begin, let's ensure that we have the appropriate using defined. The System.Collections.Generic namespace includes the classes required to work with generic collections. We have a using for it here. Now we are ready to define a generic list. We first need to declare a variable. We'll use implicit typing with the var keyword for the variable declaration. Then we set the variable to a new instance of a List of string. Next, we want to populate the list, so we'll use the Add method. We'll first add the string Red and I'll paste the rest. The list is strongly-typed, so only strings can be added to this list. If we try to add a number to the list, Visual Studio immediately displays a syntax error, cannot convert from int to string. This strong-typing keeps us from adding something into the list that is not of the correct type. Let's also try out the Insert method. We'll insert purple at Index 2. And we'll try out the Remove method. We'll remove white from the list. Lastly, we'll add a Console.WriteLine. Now let's put in a breakpoint right after the declaration. We'll use one of our unit tests to run this with the debugger. Notice that when the list is initialized, it contains 0 elements. As we step through this code, each element is added to the end of the list. The defined color is inserted in this specified position and the defined color is removed. So to use a generic list, we first declared a variable to hold a new instance of a List of string. We then populate the list using the Add and Insert methods and remove elements as needed using the Remove method. Before moving on, let's look at some generally accepted best practices for declaring and populating generic lists. Do use generic lists to manage the collections. Their flexibility and ease of use make them the best choice in most cases. Do use Add over Insert when populating the list where possible. Add simply adds the element to the end of the list. Insert requires an index, which must be valid or it will generate a runtime exception. Avoid removing elements where possible. The Remove operation is slow. First, it does a sequential search for the element before it can remove it. If you need to perform many Inserts and removals, consider a different type of generic list, such as a LINQ list as discussed later in this module. Do use a plural variable name for the list. A plural name implies that the variable holds multiple elements making the intent more clear. In the last demo, we saw how to declare a generic list and add elements to the list as two steps. If you are thinking there has to be an easier way, you are right.

Using Collection Initializers

To simplify the syntax for declaring and populating a list, we can use collection initializers, so we can change these five lines of code to one line of code like this. With collection initializers, we can populate a collection as we initialize it. Simply add curly braces after the instantiation. Within the curly braces, define the elements for the list separated with commas. Let's try this out. Here we are back in Visual Studio with the Product class open. Let's simplify our code using collection initializers. I'll copy and paste our original declaration and then comment out this code, so we still have it here for comparison. We simply define curly braces after the list instantiation and define the desired elements. I'll format it onto two lines, so it's easier to see. The elements can be a simple value, an expression, or an object initializer, which we will see later in this module. Let's set a breakpoint. We can again use the unit test to confirm that our list contains the elements we expect, and it does. So we use a collection initializer to simplify the creation of our list. Which technique do you think looks easier to read? So far, we've been working with lists of simple data types, such as a list of strings in this example. Next, let's look at how to initialize a list of objects.

Initializing a List of Objects

When building real world applications, there are often times that an object manages a list of other objects. For example, a user object has a list of preferences with a preference id, preference option name, and value. An order object has a list of order line items with an order item id, product id, and quantity. Repository classes also often manage list of objects. For example, an order repository manages the list of open orders with an order id, customer id, and order date. A vendor repository manages a list of approved vendors with a vendor id, vendor company name, and email address. A side note here, if you are new to the repository pattern, a repository class encapsulates all communication with the data source and is responsible for managing the in-memory repository of data for the application. For example, when the user requests display of the list of approved vendors, it is the Repository class that is responsible for getting that data, tracking the state of that data, for example, whether it's been changed, and saving that data as needed using the appropriate data access technology. The syntax for declaring and initializing a list of objects is the same of that used for simple types. This code declares a vendor's list variable and assigns it to a new list of vendor objects. The syntax to add elements to the list is also the same as used for simple types. The only difference here is that we need to create the instance of the element to add to the list before adding it to the list. The syntax uses C# object initializers. If you are not familiar with object initializers, they are covered in detail in the C# Best Practices: Improving on the Basics course. We can merge the two lines required to instantiate a vendor and add the vendor to the list into one line. This is one line of code, even though it is displayed on two lines here for readability. So we can instantiate and initialize the vendor directly in the Add method argument. Let's give this a try. Here we are back in Visual Studio once again, this time with the VendorRepository class open. Currently, the VendorRepository has a Retrieve method that retrieves a single vendor. In a Repository class, we'd also have an overload to this Retrieve method that retrieves all of the approved vendors from the data store and returns them. First, let's define a private class level field that retains the list of vendors. It is private so that only this class can manage the list. We declare the list specifying vendor as the generic type argument. Next, let's create the Retrieve method overload. I'll paste the code and we can walk through it. In the body of the Retrieve method, if the vendors have not yet been retrieved, we create an instance of a new list and populate it using the list's Add method. We add two vendors to the list. I'll reformat this, so it is easier to see. We are hardcoding these, but you can imagine that these were retrieved from the data store. We have a Console.WriteLine to display the vendors to the console. Lastly, we return the populated list. Let's create a unit test to run this code. Right-click within the method, and select Create Unit Tests. In the dialog, click OK to use the default settings. This creates the basic structure for our tests. I'll paste the code for the body of the test and then we can talk through it. First, we arrange everything in preparation for the test. Here we create an instance of the repository and set the expected result. For this simple test, we just confirm that we have two objects in the list. In the Act step, we call the method under test. In this case, it is the Retrieve method. We assert by checking the expected count against the actual count. Notice that a list has a Count property that returns the number of elements in the list. Before we run the test, let's put a breakpoint in the VendorRepository class in the line after the instantiation. Now we can debug the test. Go back to the test, right-click, and select Debug Test. If we have our over the vendors variable, we see that it has a list of 0 elements. Stepping through the next line, we can see that the vendors list now has one element. Drilling down, we can see the properties of the vendor object. Stepping again, we can see the vendors list now has two elements. We can drill down to see the properties of either one. Continue the test and we can see that it passes. Let's take just a moment to improve our unit test here. Currently, we are simply checking that we expected to retrieve two elements and we did retrieve two elements. Let's instead ensure that we have the two elements we were expecting. First, we changed the expected variable to the list of elements we are expecting. Then we change Assert.AreEqual to CollectionAssert.AreEqual and pass in the two lists. That seems like a better test. Let's re-run it and it fails. Element at Index 0 do not match. We get this error because the unit testing does not know how to determine if our vendor instances are equal. Are they equal if the Ids match? Do all of the fields need to match? How does the unit test determine what constitutes equality here? Let's explicitly define how two vendor objects must match for them to be equal. We do that by overriding the Equals method in the Vendor class. If you are not familiar with overriding methods, check out the C# Best Practices: Improving on the Basics course for more information. I'll paste the code to override equals and we can talk through it. Here we override Equals, which takes in an object. First, we check whether the passed in object is null and whether it is of the appropriate type. Then we use the as operator to cast the object to a Vendor type. The key part of the code is here. We define the criteria that determines whether two vendor instances are equal. Depending on our business rules, we could decide that two instances are equal if they have the same vendor id or we could decide that two instances are only equal if every property of the vendor objects are equal. We selected to check every property. If we look at our error list, we now see a warning. Since we overrode Equals, Visual Studio is telling us to also override GetHashCode. Overriding the GetHashCode method is beyond the scope of this course, but we can implement the basics here to avoid the warning. Now let's re-run our test and it passes. The unit test can now correctly determine that the vendor instances and the two lists match. Looking back at the vendor repository, to create a list of objects, such as the Vendor objects here, we declare a variable for the list. We initialize it to a new list of the appropriate type and we populate the list. Now that we know how to add elements to a list, let's look at how to get them out.

Retrieving an Element from a Generic List

Elements in a list are accessible by index. The index is zero-based meaning that the first element in the list has an index of 0. Don't confuse the index with the Id property of the object shown here. To retrieve an element from the list, we use square brackets and the index. This will retrieve the element with an index of 1, which is XYZ Inc. Let's see how this works. Here we are back in Visual Studio with the VendorRepository class open. Notice that we have a line here to write the vendors list to the console. At the bottom of the Test Explorer, click Output. We can see that writing vendors to the console displays the list type. The fully-qualified name of the generic list class is System.Collections.Generic.List. The odd '1 defines it as having 1 generic parameter. The type inside the square brackets is the type of element in the list. In this case, it displays the fully-qualified name of the Vendor class. Let's instead use the index to retrieve the second element from the list, which is the vendor with a CompanyName of XYZ Inc. If we re-run our unit test and click Output, we see the expected value, but how did we get such a nicely formatted output? If we look in the Vendor class, we can see that there is an override of the ToString method here. This code was provided as part of the starter files. The returned value of the ToString method is the text we see in the output window. The debugger and test runner use the ToString method when displaying an object instance. By overriding the ToString method, we can control exactly what is displayed. Going back to the VendorRepository, what if we retrieve an element using an index that is out of range, say 5. The compiler doesn't catch it. If we re-run our unit test, we get a runtime error. Index was out of range. Must be non-negative and less than the size of the collection. Anytime we need to retrieve an element from a list, use the list variable and specify the index of the element in square brackets. Just be sure that the index number is valid. Before moving on, let's look at some best practices when retrieving elements from a list. Do take care when referencing list elements by index. An index that is out-of-bounds will generate a runtime exception. Avoid retrieving elements by index when you need all of the elements. Iterate through the elements instead. Next, let's look at how to iterate through the elements of a generic list.

Iterating Through a Generic List

There are often times that we need to iterate through all or some of the elements in a list. For example, we loop through each string element to display it to the user or through each approved vendor to send an email. As with arrays, C# provides two ways to iterate through a generic list. Foreach, which repeats a group of statements for each element in the list, and for, which repeats a group of statements while a specific condition is true. Let's look at each of these. We are back in Visual Studio with a VendorRepository class open. In our example, we display one of the vendors to the console using the same syntax we could display each of the vendors to the console, but that would result in repetitive code that was prone to error. We can instead use a foreach statement to easily iterate through element of the list. We'll add the foreach here right after populating the list. Type foreach, tab, tab to use the Visual Studio snippet to create the foreach statement. This snippet allows us to specify the element type. We'll stick with var here to use implicit typing. Next, we define the name of the iteration variable. We'll use vendor, singular. The iteration variable is a read-only local variable that represents the current element in the list. Lastly, we specify the list variable, which is vendors, plural. In the body of the foreach statement, we define the lines of code that are repeated for each element in the list. In our example, we'll display the vendor to the console. Since we have an override of the ToString method for the Vendor class as we saw in the prior demo, we'll get a nicely formatted output. Let's try this using our unit test. Run the unit test and click Output. here we see the name of each of our vendors nicely formatted. Going back to the VendorRepository class, we can use foreach anytime we want to easily iterate through all of the elements in a list, but foreach has the same limitations here as it does with arrays. Foreach always goes through all of the elements in the list. Sure, we could have some logic here to skip elements under some circumstances, but we still need to iterate through every element. Also, when using foreach, the element itself cannot be changed. For example, say we want to replace one of the vendors with a newly initialized vendor object. If we try to change the iteration variable, Visual Studio marks it as an error. Cannot assign to vendor because it is a foreach iteration variable. Note, however, that we can change vendor object properties. For example, we could change each CompanyName to all uppercase. No syntax error here. Now let's try out the for statement. In the VendorRepository class, we can again use a snippet. Type 4, tab, tab. First, we specify the initializer variable. In most cases, we can just leave it as i. To iterate starting at the first element, we leave the default starting value at 0. Next, we specify the conditional expression. To iterate over all of the elements, we want to iterate while the index is less than the length of the list. What do we put for the length? Luckily for us, a list has a Count property, so we can use that here. Lastly, the for statement has an iterator defining how the initializer variable is modified during each iteration. If we want to iterate through every element, we can simply increase the index by one at the end of each iteration. Inside the for, we can access an element using the initializer variable as an index. So the vendors aren't displayed twice, let's comment out the other Console.WriteLine. Let's try this out using our unit test. Click on Output to view the output. And it again lists each of the vendors with their CompanyNames. Going back to the VendorRepository, unlike the foreach we could easily change this code to only process some of the elements. We could change the iteration to begin at one or end at two, for example, or process every other element by incrementing the iterator by two. Using for provides more flexibility than the foreach, but which one is easier to read? Before moving on, let's compare the two iteration techniques. When iterating a generic list, the foreach syntax is quick and easy. The for syntax is a little more complex, but is also more flexible. Foreach is useful when iterating all of the elements in a list. For is useful when iterating over all or some subset of elements. The foreach iteration variable that provides each element is read-only, so we can't modify elements as they are iterated, but we can modify the elements properties, so this is less of an issue when working with lists of objects. Using the for syntax, we can modify the element as needed. Bottom line, use foreach to quickly iterate over all of the elements of a list. Use for to iterate a subset of the elements of the list or to modify a list element when iterating through the list. Now that we have some experience working with an array and a generic list, let's broaden our scope and look at some of the different types of lists available in C#.

Types of C# Lists

Because there are so many, we'll stick to the most commonly used C# lists. And to provide some organization, we'll identify each list by the .NET namespace that is contained within. To use a particular list in C#, we'll need to ensure we have a using statement for its associated namespace. First is an array. The Array class is in the System namespace. C# has special code to help us work with arrays as we saw earlier in this course. The System.Collections namespace contains the list classes that were introduced in .NET 1, of which ArrayList was the most commonly used. The original set of .NET 1 list classes do not have the ability to define the type of their contents. That means that we cannot ensure our lists only contain strings or vendor objects, for example. This was fixed in .NET 2 with the introduction of an entirely new set of list classes. So the list classes contained in System.Collections are obsolete and should not be used. The new .NET 2 list classes leverage generics for strong-typing and the most commonly used generic lists are contained in the System.Collections.Generic namespace as listed here. These are just some of the more common list classes, but how do we decide which to use when? Use arrays if you need multiple dimensions or you need to squeeze out a bit more performance when working with a large fixed number of elements. For ArrayList and the other list classes in the System.Collections namespace, don't use them unless you are targeting .NET 1. These classes are now obsolete. You may find that you use the generic List of T most often. Use it anytime you need to track a list of anything unless some other list type is required. The generic LinkedList is a doubly linked list, which means that each element in the list is linked to both the element before it and the element after it in a sequence. Use a LinkedList when you plan to access the list sequentially following the links either forward or backward or use it if you expect to frequently insert or remove elements from the middle of the list. A generic Queue is a first in, first out list of elements. Queues are useful when you need temporary storage of elements and plan to discard the element after retrieval. This is useful if you need to retain a list of work in progress, for example. Each element can be retrieved, processed, and removed from the queue. Use a queue versus a stack if you need to access the elements in the same order in which they were added to the queue. Think of this like the line at a bank. You queue up as you arrive and you are processed in the order you are in the queue. A stack is last in, first out list of elements also useful for temporary storage of elements. But unlike a queue, elements in a stack are accessed last in, first out. Think of this like a plate of pancakes. As the pancakes are made, they are added to the stack and as the pancakes are served, the last pancake added to the stack is the first one retrieved. There are even more list classes available in System.Collections.ObjectModel. This namespace contains lists appropriate when building an object model for a reusable library that returns lists. It contains list classes, such as ReadOnlyCollection, which is used for building a collection that can be sorted and iterated, but no elements can be added or removed. And the ObservableCollection, which can be used for binding. System.Collections.Specialized is for specialty collections such as StringCollection, which manages a collection of strings. .NET 4 introduced the System.Collections.Concurrent namespace. Use the thread-safe list classes in this namespace when you need to access the list for multiple threads concurrently. Let's conclude this module with some frequently asked questions.

Frequently Asked Questions

As a review, let's look at some frequently asked questions. These are the types of questions often used in job interviews. When is it appropriate to use a generic list? Any time the application needs to manage a list of things. What are the key differences between an array and a generic list? An array is fixed length and can have multiple dimensions. A generic list can be any length and provides methods to easily add, insert, or remove elements from the list. What is the difference between foreach and for when iterating through a list? Foreach provides simple syntax for iterating all elements in a list. For provides more complex, but flexible syntax for iterating all or any subset of elements in a list. Plus the iterated elements are editable. If I use foreach on a list of objects, is the iterator object editable? The object instance is not editable, but the object properties are editable. In this module, we detailed how to define and work with a generic list. We began with a syntax for declaring and manually populating a generic list. We then tried out collection initializers for more concise code. In real applications, we often work with lists of objects, so we examined how to declare and populate a generic list of object instances. Once we had elements in a list, we wanted to get them out of the list, so we walked through how to retrieve an element from a generic list. We then looked at two techniques for iterating through the elements of a generic list, foreach and for. Lastly, we took a brief look at the many types of lists available in C#. Bottom line, use the generic list unless there is a specific reason to use something else. Next, let's look at another type of collection available in C#, dictionaries.

Generic Dictionaries

Introduction

With generic dictionaries, we can manage a collection of key and value pairs. As the name dictionaries suggest, we use them to quickly look up values. Welcome back to C# Best Practices: Collection and Generics from Pluralsight. My name is Deborah Kurata, and this module covers the what, why, when, and best practices for defining and using a generic dictionary. Earlier in this course, we divided collections into two basic kinds, lists and dictionaries. We have already seen how to work with lists, such as arrays and generic lists. Now let's focus on generic dictionaries. A generic dictionary is a strongly-typed collection of keys and values. This example is a collection of US states. The key is the state abbreviation and the value is the state name. The key must be unique within the dictionary, the key must not be changed, and the key cannot be null. Let's compare a generic dictionary to the generic list we covered in the last module. A list contains elements. A dictionary contains elements defined as key and value pairs. List elements are accessed by a positional index. Dictionary values are accessed by key. Lists allow duplicate elements. Dictionaries allow duplicate values, but the keys must be unique. Lists are generally marginally faster when iterating the entire list. Dictionaries are generally marginally faster when looking up a particular element. Note that the performance of these two collections depend on many factors, so if performance is critical for your application, try multiple kinds of collections and performance test them with your scenarios. As indicated by the name, the generic dictionary leverages generics. So the generic dictionary is written as Dictionary of TKey, TValue. TKey is the type of the element key and TValue is the type of the element value. We specify the actual types when we create an instance of the generic dictionary, so we can define a Dictionary of integer, integer for a product id and price, for example, a Dictionary of integer, string for a product id and description, Dictionary of string, string for state abbreviations and state names, Dictionary of integer, object instance. In this example, we use the unique integer product id as the key and a product instance as the value. We can then quickly locate any product in the dictionary by its product id or a Dictionary of string, object instance. In this example, we use a unique string-based product code as the key and a product instance as the value. These are just some examples. We can specify any combination of types for the dictionary key and the dictionary value. In this module, we'll start with the basics of declaring and populating a simple generic dictionary. Then we'll use collection initializers for clearer code. Because we often need to manage collections of objects, we'll examine how to declare and initialize a dictionary of object instances. Then we'll look at how to retrieve an element from a generic dictionary and iterate through all of the elements of a dictionary by element, by key, and by value. In addition to the basic generic dictionary, there are other types of C# dictionaries. We'll take a brief look at a few of them. We'll conclude with a set of frequently asked questions. These are the types of questions that you may see in a C# programming interview. Let's get started.

Declaring and Populating a Generic Dictionary

As with other collections, before we declare a generic dictionary, we need to answer the question, dictionary of what? We need to consider the type of value that the dictionary will contain. For our example, we want to store a set of US states, so we want a dictionary of string values. We also need to consider the type of key that the dictionary will contain. For our example, we want to store the state abbreviations as the key, so we want a dictionary of string keys. When working with a generic dictionary, we use the generic syntax to specify the type of key and type of value the dictionary will contain. To declare a variable as a generic dictionary, we specify the data type as a dictionary. In this example, we declare a Dictionary of string keys and string values. Next, we initialize the generic dictionary. A generic dictionary is a reference type, so it is declared similar to other reference types using the new keyword. We assign the dictionary variable to a new instance of the generic dictionary class. Here we again must specify the type of the key and type of the value. This then calls the constructor of the .NET generic dictionary class and instantiates the dictionary. So now, we have declared and initialized a dictionary of string keys and string values and the dictionary currently contains no elements. We can combine the declaration and initialization on one line like this. Notice that this is one code line even though it is displayed on two lines. Here is where we can see how the var keyword can really help readability. Because we have the dictionary type defined on the right, we can use implicit typing with the var keyword on the left as shown here. C# will implicitly determine the type of the state's variable based on the type on the right. These three techniques are functionally equivalent, though this last syntax makes the intent of this code much easier to glean. Once the dictionary is declared and initialized, we can add elements to populate the dictionary. The Dictionary class provides an Add method for adding elements to a dictionary. The first argument to the Add method is the key. The second argument to the Add method is the value. The Add method always adds the element to the end of the dictionary. So this code adds CA, California to the dictionary. We can repeat this for each state. Let's try out these features in a demo. Here we are back in Visual Studio with the Product class open. The generic dictionary is also in the System.Collections.Generic namespace, so we are ready to try it out. We'll initialize the dictionary of states here in the constructor. I've added a region, so we can collapse our code from the last module. We, first, need to declare a variable. We'll use implicit typing with the var keyword for the variable declaration. Then we set the variable to a new instance of a dictionary. For our list of states, we want the key to be a string and the value to be of type string. Next, we want to populate the dictionary, so we'll use the Add method. The first argument to the Add method is the key. We'll use the state abbreviation as the key. The second argument is the value. We'll add the state name as the value. I'll paste in two more states. Lastly, we'll add a Console.WriteLine. Both the dictionary keys and dictionary values are strongly-typed, so only string keys and string values can be added to this dictionary. If we try to add a number as the key, Visual Studio displays a syntax error. If we try to add a number as the value, Visual Studio displays a syntax error. This keeps us from adding something into the dictionary that is not of the correct type. It is also important to note that the keys must be unique. Adding a duplicate key will cause a runtime error. So let's remove our syntax errors. Now let's put in a breakpoint right after the declaration. We'll use one of our unit tests to run this with the debugger. Notice that when the dictionary is initialized, it contains 0 elements. As we step through this code, each key and value pair is added to the end of the dictionary, and when we try to add another element with the same key, we get a runtime error. So let's delete that line. To use a generic dictionary, we first declare a variable to hold a new instance of a dictionary defining the type of key and the type of value. We then populate the dictionary using the Add method. Before moving on, let's look at some generally accepted best practices for declaring and populating generic dictionaries. Do use a generic dictionary to manage a collection of elements by key. Avoid using a dictionary if the collection has no clear or unique key. Avoid using a dictionary if you don't plan to look up elements by key. In these cases, working with a list is easier and can have a small performance gain in some scenarios. In the last demo, we saw how to declare a generic dictionary and add elements to that dictionary as two steps. If you are thinking, I bet we can use the collection initializer here, you are right.

Using Collection Initializers

To simplify this syntax for declaring and populating a dictionary, we can use collection initializers. So we can change these four lines of code to one line of code like this. With collection initializers, we can populate a dictionary as we initialize it. Simply add curly braces after the instantiation. Within the curly braces, define the key and value pairs within more curly braces separated with commas. Okay yeah, this is one code line, but to be readable, it is formatted onto multiple lines resulting in more lines than our original code. So is this really better? Is it more readable? In looking at the two approaches, there is less clutter using the collection initializer, so our intent here is more clear. Let's try this out. We are back in Visual Studio with the Product class open. Let's reduce the cruft here using collection initializers. I'll copy and paste our original declaration and then comment out this code, so we still have it here for comparison. We simply define curly braces after the instantiation and define the desired key and value pairs within another set of curly braces. Now the important part of this code is easier to see without the Add method syntax. Let's set a breakpoint. We can again use the unit test to confirm that our dictionary contains the elements we expect and it does. So we are using collection initializer syntax here to clarify the creation of our dictionary. Which technique do you think looks easier to read? So far, we've been working with a dictionary with a string key and string value. Next, let's look at how to build a dictionary of objects.

Initializing a Dictionary of Objects

When building real world applications, there are often times that an object manages a dictionary of other objects. For example, a user object has a dictionary of preferences. The preferences are looked up by preference option name, so that is the key. The value is an instance of a Preference class and includes the preference id, preference option name, and preference value. Repository classes can also manage dictionaries of objects. For example, an order repository manages the dictionary of open orders. The orders are looked up by order id, so that is the key. The value is an instance of an Order class and includes the order id, customer id, and order date. A vendor repository manages a dictionary of approved vendors. The vendors are looked up by vendor company name, so that is the key. The value is an instance of a Vendor class and includes the vendor id, vendor company name, and email address. The syntax for declaring and initializing a dictionary of objects is the same as that used for simple types. This code declares a vendor dictionary variable and assigns it to a new dictionary of string vendor. The syntax defines that the keys are strings and the values are vendor objects. The syntax to add elements to the dictionary is also the same as used for simple types. The only difference here is that we need to create the instance of the vendor before adding it to the dictionary. This syntax uses C# object initializers. We can merge these lines into a single code line using collection initializers. This is one line of code, even though it is displayed across multiple lines for readability. There are a lot of curly braces here, so let's talk through it. First, we declare the vendors dictionary of string vendor. The first set of curly braces define the collection initializer. The first element in the collection has a key of ABC Corp. The value is a vendor instance. Here we use object initializers to define the data for the new vendor instance. The second element has a key of XYZ Inc. The value is a vendor instance defined again with the object initializer syntax. So this declares a vendor's variable, sets it to a new dictionary, and adds two elements with key and value pairs. Let's give this a try. We now have the VendorRepository class open here in Visual Studio. In the last module, we created this Retrieve method that returns a generic list of vendors. Let's add a RetrieveWithKeys method that returns a dictionary of vendors. I'll paste in the code. Here we create the new dictionary using the collection initializer syntax that we saw in the last slide. This adds two vendors to the dictionary using the CompanyName as the key and the vendor instance as the value. We then return the populated dictionary. Here we have hardcoded both the key and the value. In a real application, we'd retrieve the vendors from a data store, such as a database, and use that data to populate the vendor dictionary. Let's create a unit test to run this code. Right-click within the method, and select Create Unit Tests. In the dialog, click OK to use the default settings. This creates the basic structure for our test. I'll paste the code for the test and then we can talk through it. First, we arrange everything in preparation for the test. Here we create an instance of the repository and set the expected result. Here we define that we expect to get back this dictionary of elements. You'll recognize this as the collection initializer syntax. In the Act step, we call the method under test. In this case, it is the RetrieveWithKeys method. We assert by checking the expected dictionary against the actual dictionary using CollectionAssert similar to how we used CollectionAssert in the last module. Before we run the test, let's put a breakpoint in the VendorRepository class in the line after the declaration. Now we can debug the test. Go back to the test, right-click, and select Debug Tests. If we hover over the vendors variable, we can see that we have a dictionary with two elements. Drilling down, we can see the key and value of the dictionary element. Drilling into the value, we can see the properties of the vendor object. Continue the test, we can see that it passes. So to create a dictionary of object instances such as the vendor objects here, we declare a variable for the dictionary. We initialize it to a new dictionary with the appropriate type of key and type of value, and we populate the dictionary. Now that we know how to add elements to a dictionary, let's look at how to get them out.

Retrieving an Element from a Generic Dictionary

Elements in a dictionary are accessed by key. We define the key for each element when we add the element to the dictionary. So as you might expect, to retrieve an element from the dictionary, we use square brackets and the key. In this particular example, the key is a string and holds the name of the vendor company. This code then retrieves the element with a key of XYZ Inc., which is the second element here. Let's see how this works in a demo. Here we are in Visual Studio with the VendorRepository class again open. Notice that we have a line here to write the vendors dictionary to the console. We just ran this unit test, so let's see what it displays. At the bottom of the Test Explorer, click Output. We can see that writing the vendors variable to the console displays the dictionary type. The fully-qualified name of the generic dictionary class is System.Collections.Generic.Dictionary. The odd '2 defines it as having 2 generic parameters. The types inside the square brackets are the type of key and the type of value. In this case, the key is a string and the value displays the fully qualified name of the Vendor class because our dictionary value contains vendor objects. Let's instead use the key to retrieve the second element from the dictionary and display that instead. We do that by defining square brackets here and then the key. Now if we re-run our unit test and click Output, we see the expected value. As we saw in the prior module, this nicely formatted output is coming from the Vendor class ToString method. But what if we specify a key that is not in the dictionary? Let's say we typed the CompanyName incorrectly. The compiler doesn't catch it. If we re-run our unit test, we get a runtime error. The given key was not present in the dictionary. Luckily, we can check the key before we use it with a ContainsKey method of the dictionary. Let's add that code here. Note, however, that this looks up the item twice. First, it looks it up to determine if the key is found, then if it's found, it looks it up again to retrieve it. Re-run our test and it passes. Alternatively, we can use TryGetValue to check the key and retrieve the value in one statement. The TryGetValue has an Out parameter, so we need to declare a variable for it first. The first argument to the TryGetValue method is the key to get. The second argument is the variable that will hold the returned value if the key is found. The TryGetValue can be more efficient than ContainsKey because it does not have to look up the key twice. Before moving on, let's look at some best practices when retrieving elements from a dictionary. Do retrieve elements by key. Avoid retrieving elements by key if you are not sure that the key is valid. Check the key using the ContainsKey method or use TryGetValue to check the key and retrieve the value in one statement. Avoid retrieving elements by key when you need all of the elements. Iterate through the elements instead. Next, let's look at how to iterate through the elements of a generic dictionary. It's not quite as simple as iterating through a generic list.

Iterating Through a Generic Dictionary

There are often times that we need to iterate through all of the elements in a dictionary. With a dictionary, we can loop through the elements, the keys, or the values. For example, we can loop through each element to display both the abbreviation and the state name to the user, or loop through each key to display the vendor company names, or iterate through each value to send an email to each vendor. We can use foreach to iterate through the elements in a dictionary. Foreach repeats a group of statements for each element. Dictionary elements are accessed by their key and not an index, so using a for statement is not really practical. Let's try out the foreach statement to iterate the elements in a dictionary. Here we are in Visual Studio with the VendorRepository class open. In our examples, we display one of the vendors to the console. Using the same syntax, we could display each of the vendors to the console, but that would require checking each key and result in a lot of repetitive code. We can instead use a foreach statement to easily iterate through the dictionary. We can iterate through the elements, the keys, or the values. Let's first try iterating through the keys. Type foreach, tab, tab to use the Visual Studio snippet to create the foreach statement. The snippet allows us to specify the key type. We'll stick with var here to use implicit typing. Next, we define the name of the iteration variable. We'll use CompanyName to be clear. The iteration variable is a read-only local variable that represents the current key in the dictionary. Lastly, we specified the collection we wish to iterate. To iterate the keys, we can use vendors.Keys. In the body of the foreach statement, we defined the lines of code that are repeated for each key in the dictionary. Let's just display the vendors CompanyName to the console, so we no longer need this additional statement. Recall that the iteration variable is read-only, which is fine because we are iterating the keys and the keys should not be changed. Let's try this out using our unit test. Run the unit test, and click Output. Here we see the name of each of our vendors company. We can access the value of the element within the loop using that key. So we could instead output the vendor information by using the CompanyName as the key. Within the body of the foreach statement, we can use the key with confidence because we are looping through each of the existing keys. Run the unit test, and click Output. Now we see the result of the Vendor class ToString for each vendor. Instead of looping through the keys, we could loop directly through the dictionary values. Let's comment this out and create a new foreach statement. Type foreach, tab, tab to again use the Visual Studio snippet. Again, we'll stick with the var here to use implicit typing. Next, we define the name of the iteration variable. We'll use vendor because the value is an instance of the Vendor class. Lastly, we specify the collection we wish to iterate. To iterate the values, we can use vendors.Values. In the body of the foreach statement, we define the lines of code that are repeated for each value in the dictionary. We'll just display the vendor to the console, but we could have code here that performs some operation on each vendor in the list. Run the unit test again, click Output, and we again see that the vendors are displayed. To be complete, let's see how to iterate the elements of a dictionary, though that's a little more complex. Let's comment this out and build a new foreach statement. Type foreach, tab, tab to once again use the Visual Studio snippet. This snippet allows us to specify the element type. We'll stick with var here to use implicit typing. Next, we define the name of the iteration variable. We'll just use element. Lastly, we specify the collection we wish to iterate. To iterate all of the elements, we simply use our dictionary variable, vendors. Recall that each element is a key and value pair. Note that the type of the iteration variable is literally of type KeyValuePair. The KeyValuePair has two properties, key and value, which we can use to access the key or value from the element. In the body of the foreach statement, we define the lines of code that are repeated for each element in the dictionary. We can use the Value property of the element to obtain the element value, such as the vendor instance in this example. We can use the Key property to obtain the key, such as the company name in this example. Let's then display both to the console. We'll use the C# 6 string interpolation syntax. If you are using Visual Studio 2013, you can use String.Format here instead. Run the unit test again, click Output, and we see the keys and values. So we can iterate through the dictionary keys and potentially use each key to access the dictionary value or we can iterate through the dictionary values directly, and we can iterate through the dictionary elements, which are key value pairs. Before moving on, let's look at best practices for iterating through a dictionary. Do use the foreach statement to iterate a dictionary. The for statement is not as useful because dictionaries are accessed by key, not by index. Avoid iterating through the elements of a dictionary. The element type is KeyValuePair, which is a little more difficult to work with. Consider iterating through the keys or values instead. Now that we have some experience working with a generic dictionary, let's broaden our scope and look at some of the different types of dictionaries available in C#.

Types of C# Dictionaries

Because there are quite a few, we'll stick to the most commonly used C# dictionaries. And to provide some organization, we'll group them by the .NET namespace they are contained within. To use a particular dictionary in C#, we'll need to ensure we have a using statement for its associated namespace. First is the System.Collections namespace. We don't want to use the .NET 1 dictionary classes that are in the System.Collections namespace because just like the list classes in that namespace, they are obsolete and should not be used. The .NET 2 dictionary classes leverage generics for strong typing and the most commonly used dictionaries are contained in the System.Collections.Generic namespace as listed here. How do we decide which to use when? As we have seen in this module, a dictionary is a strongly-typed collection of key and value pairs. Use it anytime you need to track a collection of elements when you plan to access the elements by key and sorting is not a requirement. A SortedList is a collection of key and value pairs that are sorted on the key. Use a SortedList instead of a dictionary if you need the keys in a sorted order. A SortedList uses less memory than a SortedDictionary. It is also faster when populating the collection from sorted data. A SortedDictionary is also a collection of key and value pairs that are sorted on the key. Use a SortedDictionary instead of a dictionary if you need the keys in a sorted order. Use the SortedDictionary over a SortedList for improved performance when inserting unsorted data into the dictionary. There are even more dictionary classes available in System.Collections.ObjectModel. This namespace contains dictionaries appropriate when building an object model of a reusable library that returns dictionaries. It contains dictionary classes such as ReadOnlyDictionary and KeyedCollection. System.Collections.Specialized is for specialty collections such as an OrderedDictionary, which represents a collection of key value pairs that can be accessed by key or by index. .NET 4 introduced the System.Collections.Concurrent namespace. Use the thread-safe dictionary classes in this namespace when you need to access the dictionary for multiple threads concurrently. Let's conclude this module with some frequently asked questions.

Frequently Asked Questions

As a review, let's look at some frequently asked questions. These are the types of questions often used in job interviews. When is it appropriate to use a generic dictionary? Any time the application needs to manage a collection of things by key. What are the primary differences between a generic list and a generic dictionary? A generic list contains elements accessible by index. A generic dictionary contains elements with keys, accessible by key. What are the limitations of a dictionary key? The key must be unique within the collection. The key must not be changed. The key cannot be null. What is the difference between foreach and for when iterating through a dictionary? Okay, this is somewhat of a trick question. Since dictionary elements are accessed by key and not an index, using the for statement is often not useful. Foreach provides simple syntax for iterating all elements in a dictionary. We can iterate through the elements, the keys, or the values. In this module, we detailed how to define and work with a generic dictionary. We began with the syntax for declaring and manually populating a generic dictionary. We then tried out collection initializers. The code was not really more concise, but it did have less cruft making our intent a little more clear. In real applications, we often work with dictionaries of objects, so we examined how to declare and populate a dictionary of object instances. Once we have elements in a dictionary, we want to retrieve them, so we walked through how to retrieve an element from a generic dictionary using the key and we saw how important it is to ensure that the key is valid before using it to look up a value. We then looked at how to iterate through the keys, values, or elements of a dictionary. Lastly, we took a brief look at some of the types of dictionaries available in C#. Bottom line, use the generic dictionary unless there is a specific reason to use something else. Next, let's look at how to work with generic collections through their interfaces.

Generic Collection Interfaces

Introduction

In C#, collection classes, such as array, list, and dictionary, implement interfaces. We can work with the collections through those interfaces to write more generalized code. Welcome back to C# Best Practices: Collections and Generics from Pluralsight. My name is Deborah Kurata, and this module defines what an interface is, what it means to implement one, and best practices for using the built-in generic collection interfaces. An interface is a specification identifying a related set of properties and methods. A class commits to supporting the specification by implementing the interface. That means that the class includes code for each property and method identified in the interface. We can then use the interface as a data type to work with any class that implements the interface, so using an interface allows us to write more generalized code. Let's look at each of these points in more detail. Here is an example interface that specifies a set of properties and methods for managing a collection of elements. What you see here is a simplified version of the actual ICollection of T interface provided in .NET. Let's break down this declaration. Interfaces are declared using the interface keyword. Most interfaces are public, so they can be access from any code. This particular interface is called ICollection, and as we saw earlier in this course, the of T syntax defines it as a generic type parameter, so this is a generic interface. The properties or methods can then use T as any type. The colon here denotes inheritance. The ICollection of T interface inherits from and extends the IEnumerable of T interface. We'll talk more about IEnumerable of T later in this module. The interface body contains the specification. It simply lists the signature of the properties and methods required for this interface. Notice that there is no code here for these properties or methods. The class that implements the interface must provide the associated code. So the interface is just a specification identifying a related set of properties and methods. A class commits to providing a specific set of properties and methods by implementing an interface. As an example, here is some code from the .NET framework. This is a simplified version of the actual C# generic list class that implements the ICollection of T interface that we saw in the last slide. To implement an interface, a class must declare that it intends to implement the interface. It does that using a colon after the class name followed by the name of the interface it intends to implement. Note that this is the same syntax used for inheritance. Once the class states its intention to implement the interface, the class won't compile until there is code in the class for each property and method specified in the interface. Here again is the set of properties and methods specified in the ICollection of T interface we saw in the prior slide. This class must implement each of these properties and methods. Here is the code for the Count property and the code for the Add method. Though not shown, this class has code for each of the remaining methods in the ICollection of T interface as well. By implementing this interface, this class commits to having code for each of the specified interface, properties, and methods. We can use an interface as a data type to work with any class that implements the interface. So the SendEmail method is basically saying that it will take in any collection of vendor objects, as long as that collection has the properties and methods identified in the ICollection of T interface. In this method, we can then use the properties and methods specified in the interface because those properties and methods are guaranteed to exist in each class that implements that interface. We could have defined this first parameter as an array, or as a generic list, or as a generic dictionary, but then this method could only be used for that one type of collection. Declaring the parameter using the interface as the data type allows this method to take in differing types of collections, so code calling this method could pass in an array of vendors or a list of vendors because both array and the generic list implement the generic ICollection of T interface. We'll go through this code in more detail later in this module. Bottom line, interfaces allow us to write more generalized code because we can use the interface as a data type and an instance of any class that implements that interface can be passed in. In C#, there are built-in interfaces. Because this is a course on collections, we'll focus on the built-in generic interfaces implemented by collections, but we can also define custom interfaces in our own code. For more information on defining custom interfaces, see the Pluralsight course Object-Oriented Programming Fundamentals in C#. In this module, we start with a demo to make the case for using interfaces. We then examine the built-in generic interfaces provided in .NET that are implemented by the array and generic collection classes. We'll demonstrate how to use a generic interface as a parameter to a method and how to use a generic interface as the return type from a method. Both of these techniques make our code more generalized. Next, we take a closer look at the generic IEnumerable of T interface to see why it is often used as a return type. And we'll look at the much more advanced feature of using the yield keyword to define an iterator. This provides deferred execution and allows an iterator method to return one element at a time. We'll conclude with a set of frequently asked questions. These are the types of questions you may see in a C# programming interview. Let's get started.

Making the Case for Using Interfaces

The case for using interfaces is best illustrated with a demo. Let's jump right in. We are back in Visual Studio and looking at the VendorRepository class. Previously, in this course, we built the Retrieve method to retrieve a set of vendors and return them as a generic list. This returns two hardcoded vendors. And we built the RetrieveWithKeys method to retrieve the same set of vendors and return them as a generic dictionary. Since the last demo, I added a RetrieveArray method that returns the same set of vendors as an array. This gives us an easy way to try out working with a set of vendors as an array, generic list, or generic dictionary. Our task is to create a method that sends an email to a set of vendors. For simplicity, let's add that method to the Vendor class. I'll paste the code and we can talk through it. We define the method as static because it does not make sense to call it with a single vendor instance. We pass in a generic list of vendors and the message to send to those vendors. We want to return the confirmation messages, so we set up the variable for that. Since there will be one confirmation message for each vendor, we set up a new generic list for these messages. Then we create the instance of the emailService. The emailService class was provided with the starter files. For debugging purposes, let's display the vendor Count to the console here. Lastly, we loop through each vendor in the list of vendors, define the appropriate subject line, and send the message. We add the resulting confirmation message to our list. This is the list of messages that are returned from this method. We want to try out this method, so what are we going to do? Build a unit test of course. Right-click in the method and select Create Unit Tests, click OK, and the TestMethod signature is created. I'll paste the code for the test and we can talk through it. To arrange this test, we create an instance of the vendorRepository and call the Retrieve method to retrieve the vendors in a generic list. We also define the expected result. Since there are two vendors defined in the repository, we expect two confirmation messages. To Act, we call the method under test. To Assert, we compare the expected list of confirmation messages against the actual list. Right-click in the test, and select Run Tests, and we see that the test passes. However, this code only works if the vendors are passed into the SendEmail as a generic list. What if we want to pass the vendors in as an array? We can try that by creating another unit test. I'll copy this test, rename it EmailTestArray, and change Retrieve to RetrieveArray. The vendors variable is now an array of vendors. Notice the syntax error here, cannot convert from the array to the generic list. So our send email method is limited to working only with a generic list. We could create an overload of SendEmail that took an array and another overload that took a dictionary and remember that there are lots of different kinds of lists, so we'd need another overload for the link list, an assorted list, and so on. But there is a better way. We can use the built-in generic collection, interfaces.

Built-in Generic Collection Interfaces

There are many built-in interfaces provided in .NET. Since this course is on collections, we'll focus on the generic collection interfaces. IEnumerable of T gives a collection its ability to be enumerated using the foreach statement. IEnumerable of T specifies one method, GetEnumerator. When using a collection, we don't call GetEnumerator directly. Rather, we simply use the foreach statement to iterate over the collection. IEnumerable of T is the base interface for all generic collections. The ICollection of T interface extends IEnumerable of T. The ICollection of T specifies a property and a set of methods for basic collection operations, such as getting the count and adding and removing elements. The IList of T interface extends ICollection of T and specifies methods specifically for working with lists by index. The IDictionary of T,V interface also extends ICollection of T. It specifies properties and methods specifically for working with the collection of key and value pairs. We used these properties and methods in the last module when working with a generic dictionary. Let's look at each of the collection classes we've covered so far in this course. An array implements IEnumerable of T, ICollection of T, and IList of T, but in a non-standard way. The Array class was provided in the first release of the .NET framework before .NET supported generics. Starting with .NET framework 2, the Array class was modified to implement these generic interfaces. But these implementations are provided to arrays at runtime, and as a result, the generic interfaces do not appear in the declaration syntax for the array class, so we can work with an array through these interfaces, but we cannot access the properties and methods of these interfaces when working with an array directly. We'll see this in an upcoming demo. A generic list implements IEnumerable of T, ICollection of T, and IList of T. So we can access the properties and methods of these interfaces when working with a generic list and we can work with a generic list through these interfaces. A generic dictionary implements IEnumerable of T, ICollection of T, and IDictionary of T,V, so we can access the properties and methods of these interfaces when working with a generic dictionary as we did in the last module. And as we'll see in this module, we can work with a generic dictionary through these interfaces. When selecting which interface to use as a data type, consider this chart. For example, if we want a method to support both an array and a list, we could use the generic IList of T as the data type, but if we also want to support a dictionary, we have to move up the hierarchy and use the generic ICollection of T interface. There are many different ways to use an interface. When working with collections, the most common places to use an interface are as a parameter to a method. The calling code can pass in an instance of any collection class that implements the specified interface. We can use an interface as a return type from a method. The calling code can cast the returned value to any collection class that implements the interface. We'll see both of these techniques in upcoming demos. Another option is to implement the interface in a class. We could define a custom collection class that implements any of the generic collection interfaces. That is more of an intermediate level technique that we won't be covering in this course. Let's look at using an interface as a parameter first.

Using an Interface as a Parameter

We can use an interface as a parameter to write more generalized code. We are currently defining a specific collection type when passing the collection as a the parameter to this method, which means that this method can only take in a generic list of vendors. We can use an interface as the parameter type instead. This method can then take in an array of vendors, a generic list of vendors, a generic dictionary of vendors, or any other type of generic collection that implements ICollection. Let's see this in action. We are in Visual Studio once again looking at the SendEmail method we created in the last demo. Recall that currently our unit test has a syntax error. Our test that passes in a list of vendors works fine, but if we try to pass in an array of vendors, we see a syntax error. Going back to the SendEmail method, let's change the first parameter to use the IList generic interface as the data type in place of the generic list class. Going back to the unit test, notice that our syntax error is gone and if we run our vendor unit tests, both the test using the generic list of vendors and the test using an array of vendors passes. Looking back at our SendMail method, we can see that it is now more generalized and we can use it for any type of list that implements the IList interface. But what if we want to use the SendEmail method with a dictionary of vendors as well? Let's try that. Going back to the unit tests, I'll copy the SendEmailTest, change the name to SendEmailTestDictionary, and call the RetrieveWithKeys method to retrieve the vendors as a dictionary of key and value pairs. The vendors variable is now a dictionary. Since we want the SendEmail method to iterate the dictionary values, we'll change vendors to vendors.Values here. We now have a syntax error again. By using the generic IList interface as the SendEmail method parameter, we restrict our method to only those collections that are lists. If we move up the hierarchy, we could instead use the generic ICollection interface for our method parameter. This interface works with any type of collection. However, we won't then be able to use any specific IList methods in our method, such as Insert. Since our SendEmail method doesn't need any of the unique IList methods, let's try using the generic ICollection interface. We'll change the first parameter to use the generic ICollection interface as the data type. Going back to the unit tests, our syntax error is gone, and if we run our vendor unit tests, all three of our SendEmailTests pass. So the SendEmail method takes in a generic list of vendors, an array of vendors, or the values from a dictionary. The SendEmail method is now more generalized and we can use it for any type of collection that implements the generic ICollection interface. Now let's try something in the SendEmailTest. Recall that the VendorReposity.Retrieve method returns a generic list of vendor. Let's type Console.WriteLine vendors dot. We can see the set of properties and methods available on the generic list of vendor. These include all of the IList of T members, such as IndexOf and Insert, and all of the ICollection of T members, such as Add and Count. There are actually two Count members here, the Count property from the ICollection of T interface and the generic Count method that is an extension method. We'll talk more about extension methods in the next module. Let's select the Count property. Let's repeat this process in the SendEmailTestArray method. Recall that the VendorRepository.RetrieveArray method returns an array of vendors, so the vendors variable is an array of vendors. Now let's type Console.WriteLine vendors dot. We can see the list of properties and methods available on the array. This does not include any of the IList of T members, such as IndexOf or Insert, nor does it include any of the ICollection of T members, such as Add or the Count property. This is because the array implements these generic interfaces at runtime. If we want to display the count, we'll have to use the length property of the array class instead, but when we use the array through the interface such as in our SendEmail method, we do have access to all of the interface members, such as Count. So when working with arrays, we can use the generic interface members only if we work with the array through the generic interface. Otherwise, we can only access the members of the Array class. Before moving on, let's look at some generally accepted best practices for using an interface as a parameter to a method. Do consider using an interface instead of a concrete type when passing collections to methods. As we saw in the prior demos, using the generic IList or ICollection interface as the parameter type to our methods makes our code more generalized. Avoid using any of the interfaces in the System.Collections namespace. As with the non-generic lists and dictionaries in this namespace, the non-generic interfaces in this namespace are obsolete and should not be used. Avoid using IEnumerable of T as the parameter data type when passing collections to methods, unless the method simply iterates through the collection. That's because IEnumerable does not provide any properties or methods for working with the elements in the collection. We'll talk more about IEnumerable later in this module. We just saw how to use an interface as a parameter to a method. This makes our code more generalized and flexible because the calling code can pass in an instance of any collection class that implements the interface. Now let's look at how to use an interface as a return type.

Using an Interface as a Return Type

To write more generalized code, instead of defining a specific collection type when returning a collection from a method, we can use an interface as the return type instead. Let's give this a try. Here we are in Visual Studio once again looking at the VendorRepository class this time. We are currently returning the vendors either as an array, as a generic list, or as a generic dictionary using three separate methods. So much repeated code. We can reduce this code by defining one method that returns the vendors using one of the generic interfaces. Let's try the ICollection of T interface since that is implemented by arrays, generic lists, and generic dictionaries. Now we can delete the RetrieveArray and RetrieveWithKeys methods and their associated unit tests. Next, we need to change the vendor unit tests that use the two methods we deleted. First, the SendEmailTestArray. We change the RetrieveArray to just Retrieve. Notice now that our vendors variable is an ICollection of vendor, so we are no longer working with an array and our length property is no longer valid here. Let's change the variable name to vendorCollection to reflect that. If we want it to work with the result as an array, we need to cast it. We can cast from an interface to an array using the ToArray method. When we hover over vendors, we can see that it is now an array and we can work with the result as an array, so our length property is working again. Next, let's modify this SendEmailTestDictionary test. We can change RetrieveWithKeys to just Retrieve. Notice now that our vendors variable is an ICollection of T, so we are no longer working with a generic dictionary and our values property is no longer valid. Let's change the variable name to vendorsCollection to reflect that. Just like we did with the array, if we want it to work with the result as a dictionary, we can cast it. We can cast from an interface to a dictionary using the ToDictionary method. The parameter to the ToDictionary method is a key selector, which is a method to extract a key from each element in the collection. We want to use the CompanyName as the key. The syntax here is called a lambda expression. It basically means that for each element V in the collection, use the CompanyName as the key. We'll talk more about lambda expressions in the next module. When we hover over vendors, we see that it is again a dictionary of vendor. We can now work with the result as a dictionary and our Values property is working again. Let's make the same change to the SendEmail test. Our vendors variable is an ICollection of T. Let's change the variable name to vendorsCollection to reflect that. If we want it to work with result as a generic list, we can cast it. We cast from an interface to a generic list using the ToList method. We need to make one more change. The RetrieveTest in the VendorRepositoryTests file has a syntax error. The retrieve is returning an ICollection of vendor, so the actual variable here is of type generic ICollection of vendor. But notice that the collection Assert expects a collection that implements the non-generic ICollection interface. Luckily for us, most of the collections support both the generic and the non-generic ICollection interfaces. So to fix this, we simply add ToList here to cast the ICollection generic interface to a generic list, which implements the non-generic ICollection interface as well. Now let's run all of our unit tests and they all pass. Going back to the VendorRepository class, we can see that by returning an interface we provide a much more flexible result and allow the calling code to decide how to work with the resulting collection. Before moving on, let's look at some generally accepted best practices for using an interface as a return type from a method. Do consider using an interface instead of a concrete type when returning a collection from a method. As we saw in the prior demos, using the generic ICollection interface as the return type makes our code more generalized. Avoid using any of the interfaces in the System.Collections namespace. As with the non-generic list and dictionaries, the non-generic interfaces in this namespace are obsolete and should not be used. Do use a cast operation, such as the ToArray, ToList, or ToDictionary methods to cast the result to the desired collection type. Do use the most general generic interface that meets the requirements of your method. In many cases, IList of T may be your best choice, but if you expect that the calling code may use a dictionary, then returning ICollection of T may be better. And there are some advantages to using IEnumerable of T. Let's talk more about using IEnumerable of T as a method return type.

Returning IEnumerable T

The IEnumerable of T interface gives a collection its ability to be enumerated using the foreach statement. Returning IEnumerable of T from a method is a promise to provide a sequence of typed elements. IEnumerable of T is the base interface for the generic collection interfaces. Let's make the case for why we should consider using IEnumerable of T as the return type from a method that returns a collection. Here we are in Visual Studio looking again at the vendorRepository.Retrieve method. This method currently returns an ICollection of vendor. That means that the calling code can work with the result as any collection. The return collection is mutable meaning that it can be changed in any way. Let's try this out in the vendor tests. Let's add another test. I'll copy the SendEmailTest and change the test name to SendEmailTestAdd. The vendors collection variable is of type ICollection of Vendor. That collection provides an Add method, so let's use that method to add a vendor to the retrieve collection of vendors. The vendorsCollection now contains three vendors. Now it sort of looks like we've just modified our collection here locally. Let's call the vendorRepository.Retrieve method again to retrieve the master list of vendors. Do you think that the master list in the repository is impacted by this local change? In other words, will vendors master include this new vendor we just added to our local collection? Let's give this a try. We'll set a breakpoint, right-click, and select Debug Tests. At this point, vendorsCollection contains our two vendors as we would expect. We then add a vendor to our collection and we have three vendors. Now we re-retrieve the master list and it also has three vendors, so adding a vendor through the interface adds that vendor to our master list, in some cases, that maybe desirable. We may want the code calling our methods to add and remove elements from the list, but if our architecture is such that our repository classes manage the addition and removal of elements, then we don't want to allow this behavior. This demonstrates how IEnumerable of T can help us. If we returned IEnumerable of T instead of ICollection of T, this calling code could only iterate the collection. It wouldn't be able to add or remove elements. So let's change the vendorRepository.Retrieve method to return an IEnumerable of Vendor. Going back to our VendorTests, we see that we have a syntax error now here. The calling code can no longer add or remove elements from the collection, so let's just delete this test. Looking back at the VendorRepository class, returning IEnumerable of T is a promise to provide a read-only sequence of typed elements. This is ideal for many cases. The caller can still easily put the data into any type of collection using ToList, ToArray, and so on, but the caller can't add or remove elements from the collection. Before moving on, let's look at some generally accepted best practices for using IEnumerable of T as a return type from a method. Do consider returning an IEnumerable of T to provide an immutable collection. The calling code can then only iterate the collection or work with individual elements in the collection. It cannot add or remove elements from the collection. Another option is to use the read-only collection, which provides a specific generic read-only collection. Avoid returning an IEnumerable of T if the returned collection must be modified by the caller. Avoid returning an IEnumerable of T if the calling code requires information about the collection, such as the count. IEnumerable of T does not provide any information about the collection. Avoid returning an IEnumerable of T if the caller must be notified of a change to the collection. There is no easy way to implement notifications. Do consider returning an IEnumerable of T if you don't know how the calling code will use the collection. Returning IEnumerable of T allows the calling code to decide when and how to cast the result to a specific collection type. There is another option that we did not cover here, IQueryable of T. IQueryable of T is a generic interface that works with query providers, such as LINQ to SQL and Entity Framework. Consider using IQueryable of T instead of IEnumerable of T as the return type when working with a query provider. We'll talk more about LINQ in the next module. Now let's cover a little more advanced scenario, returning elements one at a time using an iterator.

Defining an Iterator with Yield

There may be cases where we want to return the elements from a collection one at a time. For example, we return calculated elements from an infinite collection such as the prime numbers or the Fibonacci sequence as shown here or we have a large collection of elements and don't want them all in memory at once or we want to start working with each element before the entire collection is processed. To achieve this object, we can use an iterator with a yield return statement. Let's try this out. Here we are in Visual Studio once again looking at the VendorRepository class. We want our Retrieve method to return one element at a time, but for demo purposes, we want to keep the original Retrieve method here, so let's just create a new method. I'll paste the code for a new RetrieveWithIterator method. This new method is an iterator method that performs a custom iteration over a collection. It uses the yield return statement to return each element one at a time. The return type of an iterator method must be an IEnumerable type. In the method, first we fake getting the data from a database by simply calling our original Retrieve method. That populates our class level vendors list variable. We then loop through each element in that list. We display the elements Vendor Id for debugging purposes. Here we are using the C# 6 string interpolation feature. If you are using Visual Studio 2013, you can use String.Format instead. The key line is this one, yield return vendor. When the yield return statement is executed, the current location in this code is remembered. The single vendor is returned to the calling code and processing continues there. The execution of this method is restarted from the remembered location the next time the Iterator method is called. The iterator is consumed from the calling code using a foreach statement or with a LINQ expression. LINQ is short for Language Integrated Query. We'll look more at LINQ in the next module. Let's consume this iterator with a unit test. I'll paste the code and we can talk through it. To Arrange, we create an instance of the VendorRepository. We set the expected value to our List of Vendors. To Act, we call the method under test. Then we use a foreach statement to iterate over the returned iterator. Since we are returning an IEnumerable of T, we don't have properties, such as Count, or features, such as indexing. We can get those features if we use ToList to cast the result to a list. To Assert, we compare the expected list to the actual list. Let's put in a breakpoint, so we can see what is happening. We'll put it on the first line of the Act, and let's move the VendorRepository, so we can see it as well. We'll add a breakpoint here on the foreach, right-click, and select Debug Tests, then we'll start walking through this code. Let's unpin Solutions Explorer, so we have a little more space. Even though this line calls the RetrieveWithIterator method, notice that it does not yet step into the RetrieveWithIterator method here. We step through the foreach statement and then when processing the first element, the code jumps into the RetrieveWithIterator method, so it doesn't actually execute the method we called until we iterate the first element. This technique is called deferred execution. We loop through one iteration and yield return jumps us back to the outer loop. Keep stepping. Now we are back in the RetrieveWithIterator method, exactly where we left off. We loop through the next iteration and yield return jumps us back to the outer loop. Now we are again back in the RetrieveWithIterator method exactly where we left off. Keep stepping. We only have two elements, so this loop is complete. Step some more, and we'll return to the outer loop. Step again. Now we are calling ToList on the iterator. Guess what happens next. Step. Yep, we again execute the RetrieveWithIterator method and iterate the entire list. Let's not do that again here. We'll just complete the test. So what conclusions can we draw from this demo? There are two things going on here, deferred execution and lazy evaluation. Using the yield return statement provides deferred execution. That is the method containing the yield return is not executed until the collection is iterated. Either with a foreach, or a cast, such as ToList, or LINQ as we'll see in the next module. Using the yield return statement also provides lazy evaluation. That is the method containing the yield return only returns one element at a time. That way we can return only the elements we need and the calling code can process each element as it is received, but we need to be careful how we use the returned value. Otherwise, we could iterate over the collection multiple times as we saw here. Before moving on, let's look at some generally accepted best practices for defining an iterator. Do use an iterator if a method should return one element at a time. This is sometimes called lazy evaluation and is useful when the calling code wants to process each element as it is received or when returning an infinite number of elements, such as prime numbers, the Fibonacci sequence, or future dates of holidays. Do use an iterator for deferred execution. Deferred execution is when evaluation of an expression, such as a method call, is delayed until its value is actually required. Deferred execution can greatly improve performance when working with large data collections, especially in cases involving a series of queries or manipulations. If used correctly, when working with a series of queries, deferred execution can provide a single iteration through the source collection. We'll see more of that in the next module. Avoid using an iterator if it is not required. If the method always returns an entire list, there is no point in using an iterator. Using an iterator can be confusing for the calling code and when stepping through the code for debugging. Now let's conclude this module with some frequently asked questions.

Frequently Asked Questions

As a review, let's look at some frequently asked questions. These are the types of questions often used in job interviews. What is an interface? A specification for identifying a related set of properties and methods. What does it mean to say that a class implements an interface? It means that a class commits to supporting the specification defined in the interface by implementing code for each property and method identified in the interface. What is the primary benefit of using an interface as a data type? We can write more generalized code when defining properties, method parameters, or method return values. The generalized code then works with any class that implements the interface. What features does the IEnumerable of T interface provide? The ability to iterate through a collection using foreach, for example. What features does the ICollection of T interface provide? The ability to work with a collection, add or remove elements, and get the element count, for example. What features does the IList of T interface provide? The ability to work with generic lists by index, locate elements by index or insert at a specific index, for example. In this module, we detailed how to work with the generic interfaces that are implemented by C# collections. We began with a demo to make the case for using interfaces. We saw that using an interface as a data type instead of using a specific collection type helps us write more generalized and more reusable code. We then examined the built-in generic interfaces provided in .NET that are implemented by the array and generic collection classes. We tried out a generic interface as the data type for a parameter to a method. By using an interface, one method could work with an array or a generic collection. Then we used a generic interface as the return type from a method and saw that returning an interface gives the calling code flexibility and how it works with a method result. Next, we took a closer look at the IEnumerable of T interface. We can use IEnumerable of T to return a read-only sequence of elements. Lastly, we looked at using the yield keyword to define an iterator and saw how we could use an iterator for deferred execution and to return one element at a time. In summary, when passing a collection in as a parameter to a method, define the collection type as a generic interface, such as IList of T or ICollection of T. This gives the calling code more options on the types of collections it can pass in. When returning a collection from a method, consider using IEnumerable of T. IEnumerable of T returns a read-only sequence of elements. The calling code can then iterate the list as needed, but it can't modify the original source collection. The calling code can optionally cast the result to any other type of collection for its own use. Also, return IEnumerable of T from a method that uses the yield return statement for deferred execution. But returning IEnumerable of T puts a burden on the calling code. The calling code must understand how to work with an IEnumerable of T and the calling code cannot modify the original source collection, not even to sort it. Consider returning IList of T or ICollection of T to return an updatable collection. The calling code then has a feature rich result that it can then iterate or update as needed. This gives the calling code a result with minimal complexity and the most flexibility. Otherwise, return a specific collection type such as a generic list, an array, or a generic dictionary. This gives the calling code a specific simple and easy to use result. The calling code can then work with the provided type. Consider what the calling code is expecting to do with the collection to help you select which interface or collection type to return in any particular situation. Next up, let's see how to do some really cool things with collections using LINQ.

LINQ

Introduction

LINQ, or Language Integrated Query, allows us to write queries against a data source including in-memory collections, so we can use LINQ to filter, shape, order, group, aggregate, or locate elements in our collections. Welcome back to C# Best Practices: Collections and Generics from Pluralsight. My name is Deborah Kurata, and this module provides a brief overview of LINQ with a focus on using LINQ to query our collections. LINQ, or Language Integrated Query, is a way to express queries against a data source directly from a .NET language, such as C#. What kind of data source? Any data source that has a LINQ provider and there are a lot of them. LINQ to objects allows us to query any in-memory collection that implements an IEnumerable interface, so we can use LINQ to objects to query any of our collections. LINQ to SQL works with SQL Server databases. LINQ to entities works with Entity Framework. LINQ to XML works with any XML document. And there are many, many more. In addition, we could create our own LINQ provider for our own custom data source. Since this course is on collections, we will focus exclusively on LINQ to objects, but everything you see here is applicable when working with any data source that has a LINQ provider. There are two different ways to express a LINQ query. We can use the query syntax to express our query in a form similar to SQL. From v in vendors, this defines the data source and an alias for each element iterated from that data source. Where v.CompanyName.Contains Toy, this is our filter. We want it to check each vendor v in the collection and only return the vendors with a CompanyName that contains the text, Toy. Orderby v.CompanyName, this orders the result by the vendor's CompanyName. Select VM, this selects the matching vendors into the result if the defined criteria are met. Alternatively, we can use the method syntax. In .NET, LINQ was implemented by adding a large set of extension methods to the IEnumerable interfaces, instead of using the query syntax, which is turn calls the LINQ extension methods, we can call those extension methods directly. We identify the data source here, then we call the Where method and pass a lambda expression defining our filter clause, and then we call the OrderBy method passing in a lambda expression defining the string for the ordering. These two are functionally equivalent, but many developers prefer the method syntax because it calls the methods directly. Okay, so what is an extension method? And what is a lambda expression? An extension method is a method added to an existing type without modifying the original type. The LINQ standard query operators are all extension methods on the IEnumerable and IEnumerable of T interfaces. By using extension methods, LINQ was added to .NET without modifying the existing IEnumerable code. We can also build our own extension methods and extend any existing .NET class, such as string. See the Pluralsight course Object-Oriented Programming Fundamentals in C# for more information on building your own extension methods. For this course, our focus is on the built-in extension methods we use to query our collections. Many of the LINQ extension methods take a delegate in as an argument. So what's a delegate? A delegate is a type that represents a reference to a method with a specific parameter list and return type. Delegates are used to pass methods as arguments to other methods. For example, here is the Where extension method for filtering a collection of vendors using LINQ. This slider text is a placeholder that displays the definition of the Where method parameter. The Where method has one parameter a Func, a Vendor, bool generic delegate. Though this looks a little complex, this delegate simply represents a method that has one parameter of type vendor and returns a Boolean value. Any method with a matching signature can be passed into this Where method, such as this one. This method has one parameter of type Vendor and returns a Boolean value. So we can pass the name of this method in as the argument to the Where method, but more commonly, delegate arguments are expressed with a lambda expression. So what's a lambda expression? A lambda expression is a method that can be passed as an argument to another method when that argument is expecting a delegate type. Lambda expressions are particularly helpful for writing LINQ query expressions. As we saw in the prior slide, the WHERE clause expects a delegate argument that has one parameter and returns a Boolean value. So the lambda expression defined here takes in one parameter and returns a Boolean value. Let's break down this syntax. The code on the left lists the parameters to this unnamed method we are defining here. The parameter list is contained in parentheses, which can be dropped when there is only one parameter as in this example. In this case, the parameter is the vendor instance. The fat arrow here is called a lambda operator. This is a shortcut syntax for defining a method. The code to the right defines the body of the method. In this example, it is the simple statement that defines our desired criteria. If the vendor's company name contains the text, Toy, then the method returns true. When this query is executed, the collection defined here is iterated and each vendor is passed into this method. This method then determines whether or not each vendor should be included in the returned results. If all of this looks Greek to you, that's okay. We'll see how all of this works in this module. We'll start by building a simple LINQ query using the query syntax. Then we'll build this same query using the method syntax passing in named methods for the delegate arguments. Next, we'll see how to simplify the method syntax using lambda expressions. We'll take a brief look at the many features that LINQ provides for querying collections and conclude with a set of frequently asked questions. These are the types of questions you may see in a C# programming interview. Let's get started.

Building a LINQ Query: Query Syntax

The LINQ query syntax allows us to query our collections using a SQL-like structure. Let's jump right into a demo and try out a LINQ query using the query syntax. Here we are in Visual Studio with the VendorRepository class open. We are looking at the Retrieve method we've been working with throughout this course. We only have two vendors defined here, which does not provide much data to query. We could add more vendors here, but then we'd break our unit tests. So let's add a new method that creates a larger list of vendors, so we have more data to work with. I'll paste the code. This code is similar to the code we created in the original Retrieve method. We create a new instance of a list using collection initializers and return the resulting list. We've hardcoded these here, but in a real application, these would be retrieved from a data store, such as a database. Now let's create a unit test to try out some LINQ. First, we need to ensure we have the appropriate using directive for LINQ. Here it is, System.Linq. Then we can build our unit test. I'll paste the code for the basic test, then we can build the query. We arrange by creating a new instance of the repository and define our expected result. Only vendors with a CompanyName containing the text, Toy, are included here. We Act by calling the method under test, and here we'll build our query. We Assert that the expected list matches the result of our query. Now let's build that query. Our task is to filter the list of vendors to only those that contain Toy in their name. We start by declaring a variable for the query. We'll use inferred typing here with the var keyword. The query begins with a from clause. We specify an alias for each element in the data source and identify the source of the data. We want to query the collection of vendors. Then we add a where clause specify our filter criteria. We only want a vendor returned if the vendor's CompanyName contains the text, Toy. If the vendor matches, we select that vendor using the alias v. That's it. If we hover over the vendor query variable, we see that this LINQ query returns an IEnumerable of Vendor. This is why we love inferred typing and the var keyword. It is important to know that LINQ supports deferred execution, meaning that this LINQ query is not executed until the resulting collection is iterated. In our case, we are doing this here when we cast to a list. We saw more details of deferred execution in the last module. So here is where we define the query, but the query is not executed until we iterate the result, which we do here. Let's run it. We'll put in a breakpoint on the first line of the Act and on the Where clause. Now let's debug the test. As we step through, we can see that it retrieves the vendors, creates the query, and then executes the Assert. When the code casts the query to a list, it is then that the collection is iterated and the query actually executes. The query passes each vendor in the collection to the Where clause, which determines whether the vendor should or should not be included in the returned result. We have a lot of vendors in our lists, so now let's just take off the breakpoint, and continue. And we see that the test passes. So only those vendors containing the text, Toy, as shown in our expected list, were included in the result. What if we want the returned list to be sorted? We can simply add an orderby clause to our LINQ query. Let's order by each vendor's CompanyName. We'll need to change our expected result as well, re-run our test, and it passes. Now our list of vendors is sorted by their company name. Let's see how this same query looks using the method syntax.

Building a LINQ Query: Method Syntax

With a LINQ query method syntax, we call the IEnumerable extension methods to define the query. To use the LINQ extension methods, we work with a collection that implements the IEnumerable or IEnumerable of T interface. As we saw in the last module, IEnumerable of T is the base interface implemented by an array and all of the generic collection classes, so we can use method syntax with an instance of any collection class such as an array, a generic list, or a generic dictionary or we can use an instance through any of the generic collection interfaces, such as IList of T, ICollection of T, or IEnumerable of T. Both the Where and the OrderBy extension methods take a delegate as a parameter, so we can define a method with appropriate parameters and return type. Notice that we are using the C# 6 expression-bodied method syntax with a lambda operator here. This is just shortcut syntax when defining a simple one-line method. Then we pass the method name to the where extension method and we do the same for the OrderBy extension method. Let's jump into a demo and try out the LINQ query method syntax. We are back in Visual Studio with the VendorRepositoryTest file open. Let's leave the LINQ query syntax here for comparison purposes. We'll just comment it out. We have the same task to filter a collection of vendors to only those that contain Toy in their CompanyName and to order them by CompanyName. We, again, start by declaring a variable for the query. We'll use inferred typing here with the var keyword. Then we specify the data source, which, in this example, is the collection of vendors returned from the repository. Type dot. See all of the methods here? Many of them are marked with extension. These are the LINQ extension methods. Let's go through each one. Just kidding. We want to define a filter, so we'll use the Where extension method. As shown in the tooltip, the Where method takes a delegate. The delegate requires a signature as defined by the func generic type parameters. The first generic type parameter defines the data type of the delegate method parameter. The last generic parameter is the return type of the delegate method. In other words, the Where method wants a method as an argument. That method must has one parameter, vendor, in this example, and must return a bool. So let's create a method with a signature as required by this delegate. We can make our new method private since only this Where clause will need this method. As defined by the delegate, the return type must be a Boolean. We'll call the method FilterCompanies. As defined by the delegate, the method must have one parameter of type vendor. For the body, we can use the same expression as in the query syntax example. This method returns true if the vendor matches our desired criteria. So our signature here matches the requirements of the delegate for the Where extension method. We can then pass this method in by name. Since this is a single-line method, we can use the expression-bodied method syntax from C# 6. We remove the curly braces defining the body of the method and replace the return statement with a lambda operator. That's a bit more concise. Next, we want to order the collection, so we can call the OrderBy extension method. We can call that method directly on the result of the Where method. The OrderBy method also takes a delegate. The delegate requires a signature as defined by the func generic type parameters. The first generic type parameter defines the data type of the delegate method parameter. The last generic type parameter is the return type of the delegate method. Now let's create a method with a signature as required by this delegate. We create a private method because only our orderby clause will call this method. As defined by the delegate, the return type is the type of the key to order on, in our case, a string. We'll call the method OrderCompaniesByName. As defined by the delegate, the method must have one parameter of type vendor. Since this is a simple method, we'll again use the expression-bodied method syntax. Now our method matches the required delegate type and we can pass the method name into our OrderBy. Recall that this line of code simply defines the query. It does not execute it. The query won't be executed until the result is iterated, which occurs here when we call ToList. When this query is executed, our Filter method and our OrderBy method are called for each vendor in the collection of vendors. So that's it. Instead of the query syntax, we simply call the LINQ extension methods and pass in delegates containing the code we want LINQ to use. We can run the unit test and it still passes. The code here can get messy quickly. We end up with all of these little methods whose only purpose is to provide support for our query operations. There has to be a better way.

Using Lambda Expressions

The better and more common way to build a LINQ query with a method syntax is to pass in a lambda expression as the delegate. Let's see how lambda expressions can reduce the clutter in our code. We are back in Visual Studio with the VendorRepositoryTest file open. We'll leave the original syntax here for comparison purposes. We'll just comment it out. Now let's build the LINQ query with the method syntax again, but this time using lambda expressions. We start by declaring a variable for the query. We use the vendors returned from the repository. We wanted to find a filter, so we again select the Where extension method. As shown in the tooltip, the Where extension method takes a delegate. Instead of defining a separate method and passing that method in as the delegate, we'll use a lambda expression. The func delegate wants a vendor passed into the method, so we specify the vendor parameter with a v, then the lambda operator, then the method that defines our filter. The func delegate expects our Filter method to return a Boolean value, so we use the same expression to filter the vendors to only those with a CompanyName containing Toy. Basically, we've taken the code from the FilterCompanies method and placed it directly as the argument to the Where method. We can do the same thing with the OrderBy clause. We'll just take the code from our OrderCompaniesByName method and place it directly as the argument to the OrderBy method. So that's it. Instead of passing in a method by name, we pass in a lambda expression. Let's comment out these extra methods. We can run the unit test and it still passes. Using lambda expressions with the LINQ method syntax keeps the code all in one place. So now we can compare these three techniques, using the query syntax, using the method syntax passing in method names, and using the method syntax with lambda expressions. Which technique do you think is easier to build? Which one is easier to read? Will your answers change here after working with LINQ for a while? So far, we have only seen the where and the orderby LINQ operators. Let's look at some of the other LINQ query operators that are commonly used with collections.

LINQ and Collections

As we can see with Visual Studio's IntelliSense, there are many LINQ query operators available as extension methods on IEnumerable of T. We can recognize extension methods here by the drop-down arrow and the member icon. Since IEnumerable of T is implemented by every collection type, we have access to these methods from every collection. Let's look at some of the more commonly used LINQ query operators to filter, shape, order, group, aggregate, or locate elements in our collections. In the last clip, we saw how to use the Where method to filter a collection based on filter criteria and the OrderBy method to sort on a defined string. We can shape the resulting collection to contain specific properties. This Select method returns a collection of strings containing the email addresses of each vendor. We can use the select to select any subset of properties that we need. We can group our results using the GroupBy method. In this example, we assume that we've defined a category for the vendors, such as local vendors, regional vendors, and overseas vendors. We can then group the vendors by their category. We can aggregate elements in our collection to get the minimum, maximum, sum, or average value. In this example, we assume that there is a vendor property defining the number of products that the vendor sells. We can then determine the average number of products a vendor sells using the average aggregate LINQ query operator. We can find the first matching element using the first method. This finds the first element in the collection matching the defined criteria. There is also a Last method. The problem with the First method and Last method is that if LINQ does not find a matching element, it throws an exception. A better option is to use FirstOrDefault or LastOrDefault. This returns the first matching element or the appropriate default value if the matching element is not found. When working with reference types, the default is null. So if a match is not found, it returns null, which is better than an exception. And we can combine LINQ query operators as needed. In this example, we filter the collection to only those containing the text, toy, then we group that by the vendor category, and select to return the total number of products sold by vendors in each category. Here the g represents the group from the GroupBy clause. Since this course is focused on collections, not LINQ, we only demoed where and orderby. Feel free to try out some of these or other LINQ query operators by modifying our unit test. Before moving on, let's look at some LINQ best practices. Do use LINQ. LINQ is great for filtering, shaping, ordering, grouping, aggregating, or locating elements in our collections. Sure, we could loop through our collections ourselves to perform these operations, but why write your own Where method or Average method or OrderBy method when you can use a built-in and tested one. Do consider using the method syntax over the query syntax. The method syntax is easier to read and work with as the query gets more complicated. Do wait to cast the result to a list or other concrete type until after all query operations are defined. Because of LINQ's deferred execution, we can define a set of query operations. None of those queries are executed until the result is iterated by a cast to a list, for example. This ensures that the source collection is enumerated a minimum number of times. Avoid iterating over the collection more than is required. Pay special attention to LINQ's deferred execution to ensure you don't iterate over the collection more often than you need. Avoid using the First or Last extension methods. Use FirstOrDefault or LastOrDefault instead. First and last throw an exception if there are no elements matching the criteria. FirstOrDefault or LastOrDefault return the matching element or the default value appropriate for the collection type, such as null for reference types. Let's conclude this module with some frequently asked questions.

Frequently Asked Questions

As a review, let's look at some frequently asked questions. These are the types of questions often used in job interviews. What is LINQ? Language Integrated Query. A way to express queries against a data source from a .NET language, such as C#. What types of data sources work with LINQ? Any data source that has a LINQ provider. LINQ to objects, LINQ to SQL, LINQ to Entities are all examples. What is an extension method? A method added to an existing type without modifying the original type. The LINQ standard query operators are all extension methods. What types do the LINQ extension methods extend? IEnumerable and IEnumerable of T. Because all collections implement one of these interfaces, LINQ works great with any collection type. What is a delegate? A data type that represents a reference to a method with a specific parameter list and return type. A delegate is used to pass methods as arguments to other methods. What is a lambda expression? A method that can be passed as an arguments to another method when that argument expects a delegate type. Lambda expressions are helpful for writing LINQ query expressions. In this module, we saw a very brief overview of using LINQ with C# collections. We began with a demo of LINQ using the LINQ query syntax. This syntax is similar to SQL. We then examined how to build the same LINQ query using the LINQ extension methods syntax. Many of the LINQ extension methods take in a delegate as an argument. We first tried out the method syntax passing in a method that matched the requirements of the delegate. We then saw how to use a lambda expression to define the delegate in line. This helps us write much more concise code and keeps our code from getting cluttered with little tiny methods. Lastly, we looked at several commonly used LINQ operators to filter, shape, order, group, aggregate, or locate elements in our collection. For more information on using LINQ, check out these Pluralsight courses. Practical LINQ provides a detailed overview of LINQ and then covers practical uses of LINQ by way of examples. LINQ Fundamentals is an older course that covers the general purpose query features of LINQ. And Querying the Entity Framework provides a detailed look at LINQ to Entities. Only one module left.

Final Words

Introduction

As you have seen throughout this course, there is more to learning C# than just the fundamentals. It is important to understand the when, why, and best practices. Welcome back to C# Best Practices: Collections and Generics from Pluralsight. My name is Deborah Kurata, and the final words in this course include some takeaways and a few pointers to additional information. Let's jump right into this short module.

Takeaways

As an apprentice, the goal is to become a skilled craftsperson. Just as a craftsperson takes pride in the craft they produce, so do we. By learning best practices, we can write code that we proudly commit and confidently pass along. Throughout, this course provided many tips and techniques you'll need as you thoughtfully craft your code. Here are some takeaways to polish your skills with collections and generics. Arrays are a classic data structure that still has some purpose in modern day applications. Arrays are fixed length, and therefore, appropriate when the list length is known. You may find that you only use arrays when you need multiple dimensions or to squeeze out a bit more performance when working with a large fixed number of elements. However, you may discover that you use the generic List of T much more often. Generics provide a technique for defining a data type using a variable. With generics we can build more generalized and reusable code that works with different data types in a strongly-typed manner. Recall our OperationResult generic class. When we create an instance of this class, we can tailor it to work with an integer, Boolean, string, or whatever. Generics are what make today's collections strongly-typed. The generic list is the work horse of collections in .NET. It is often the first choice for a collection, unless some other collection has better fitness for the purpose. With the list, we can readily add, insert, or remove elements. We can retrieve an element by index and we can iterate through the elements processing each one. The generic dictionary is similar to a generic list, but each element in a dictionary has a unique key. We can add or remove elements by their key, we can retrieve an element by the key, and we can iterate through the dictionary by element, by key, or by value. The array and all of the generic collections implement a specific set of interfaces, including IEnumerable of T, ICollection of T, and IList of T or IDictionary of T. We can work with our collections through one of these interfaces. We can use an interface as the type of a method parameter allowing the method to take in different types of collections, and we can use an interface as a return type from a method allowing for flexibility and how the resulting collection is used. LINQ, or Language Integrated Query, is a way to express queries against a data source directly from a .NET language, such as C#. We can use LINQ to objects to query our collections. We can build a query using the query syntax, which looks like SQL as shown here or we can build a query using the method syntax, which involves calling extension methods on IEnumerable. In this example, we're using the Where and OrderBy extension methods. When using the method syntax, many of the methods require passing in a delegate. A delegate is a type that represents a reference to a method with a specific parameter list and return type. That delegate is often expressed using a lambda expression as shown here. We can use LINQ with any collection to filter, shape, order, group, aggregate, or locate elements in our collections. So these are the concepts that we covered in this course.

For More Information

This course covered tips and best practices for C# collections and generics, but there is much more to both than what I could show you here. Check out these other great courses from the Pluralsight library to expand your skills with C# collections and try out these courses to expand your skills with generics. Feel free to pause if you want to add any of these to your Pluralsight playlist. We also covered interfaces and LINQ in this course. For more information on using C# interfaces in your applications, check out these other great courses from the Pluralsight library. And for more information on LINQ, try one of these. As a reminder, I have set up a GitHub repository for this course. It is called CSharpBP-Collections. It contains the starter files for this course to help you code along with the demos. I'll also add notes and reference materials as needed. Note that these are only the starter files and not the completed source code.

Closing

Congratulations. You have completed the next phase of your apprenticeship. You can now leverage what you've learned in this course to masterfully implement C# collections and generics using appropriate techniques and best practices. Thoughts or comments, please use the Discussion tab on the Pluralsight page for the course and leave your feedback. It would be great to hear your thoughts and your experiences regarding best practices dos and avoids. Thanks for listening.